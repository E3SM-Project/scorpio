PIO_TF_TEMPLATE<PIO_TF_PREDEF_TYPENAME PIO_TF_DATA_TYPE, PIO_TF_PREDEF_TYPENAME PIO_TF_FC_DATA_TYPE>
PIO_TF_AUTO_TEST_SUB_BEGIN test_put_1datt
  Implicit none
  type(file_desc_t) :: pio_file
  character(len=PIO_TF_MAX_STR_LEN) :: filename
  type(var_desc_t)  :: pio_var, pio_cvar
  integer :: pio_dim
  integer, parameter :: DIM_LEN = 100
  PIO_TF_FC_DATA_TYPE, dimension(DIM_LEN) :: val
  CHARACTER(len=DIM_LEN) :: cval
  integer, dimension(:), allocatable :: iotypes
  character(len=PIO_TF_MAX_STR_LEN), dimension(:), allocatable :: iotype_descs
  integer :: num_iotypes
  integer :: i, ret
  
  val = pio_tf_world_sz_
  cval = "DUMMY_STRING"
  num_iotypes = 0
  call PIO_TF_Get_nc_iotypes(iotypes, iotype_descs, num_iotypes)
  filename = "test_pio_ncdf_get_put.testfile"
  do i=1,num_iotypes
    PIO_TF_LOG(0,*) "Testing type :", iotype_descs(i)
    ret = PIO_createfile(pio_tf_iosystem_, pio_file, iotypes(i), filename, PIO_CLOBBER)
    PIO_TF_CHECK_ERR(ret, "Failed to open:" // trim(filename))

    ! Since file is just created no need to enter redef
    ret = PIO_def_dim(pio_file, 'dummy_dim_put_val', DIM_LEN, pio_dim)
    PIO_TF_CHECK_ERR(ret, "Failed to define dim:" // trim(filename))

    ret = PIO_def_var(pio_file, 'dummy_var_put_val', PIO_TF_DATA_TYPE, (/pio_dim/), pio_var)
    PIO_TF_CHECK_ERR(ret, "Failed to define var:" // trim(filename))

    ret = PIO_def_var(pio_file, 'dummy_var_put_cval', PIO_char, (/pio_dim/), pio_cvar)
    PIO_TF_CHECK_ERR(ret, "Failed to define char var:" // trim(filename))

    ret = PIO_put_att(pio_file, pio_var, 'dummy_att_put_val', val);
    PIO_TF_CHECK_ERR(ret, "Failed to put attribute:" // trim(filename))

    ret = PIO_put_att(pio_file, pio_cvar, 'dummy_att_put_cval', cval);
    PIO_TF_CHECK_ERR(ret, "Failed to put char attribute:" // trim(filename))

    ret = PIO_enddef(pio_file)
    PIO_TF_CHECK_ERR(ret, "Failed to enddef:" // trim(filename))

    call PIO_closefile(pio_file)
    call PIO_deletefile(pio_tf_iosystem_, filename);
  end do
  if(allocated(iotypes)) then
    deallocate(iotypes)
    deallocate(iotype_descs)
  end if

PIO_TF_AUTO_TEST_SUB_END test_put_1datt

PIO_TF_TEMPLATE<PIO_TF_PREDEF_TYPENAME PIO_TF_DATA_TYPE, PIO_TF_PREDEF_TYPENAME PIO_TF_FC_DATA_TYPE>
PIO_TF_AUTO_TEST_SUB_BEGIN test_put_get_1datt
  Implicit none
  type(file_desc_t) :: pio_file
  character(len=PIO_TF_MAX_STR_LEN) :: filename
  type(var_desc_t)  :: pio_var, pio_cvar
  integer :: pio_dim
  integer, parameter :: DIM_LEN = 100
  PIO_TF_FC_DATA_TYPE, dimension(DIM_LEN) :: pval, gval
  PIO_TF_FC_DATA_TYPE :: init_val
  CHARACTER(len=DIM_LEN) :: pcval, gcval
  integer, dimension(:), allocatable :: iotypes
  character(len=PIO_TF_MAX_STR_LEN), dimension(:), allocatable :: iotype_descs
  integer :: num_iotypes
  integer :: i, ret
  
  init_val = pio_tf_world_sz_

  pval = init_val
  pcval = "DUMMY_STRING"
  num_iotypes = 0
  call PIO_TF_Get_nc_iotypes(iotypes, iotype_descs, num_iotypes)
  filename = "test_pio_ncdf_get_put.testfile"
  do i=1,num_iotypes
    PIO_TF_LOG(0,*) "Testing type :", iotype_descs(i)
    ret = PIO_createfile(pio_tf_iosystem_, pio_file, iotypes(i), filename, PIO_CLOBBER)
    PIO_TF_CHECK_ERR(ret, "Failed to open:" // trim(filename))

    ! Since file is just created no need to enter redef
    ret = PIO_def_dim(pio_file, 'dummy_dim', DIM_LEN, pio_dim)
    PIO_TF_CHECK_ERR(ret, "Failed to define dim:" // trim(filename))

    ret = PIO_def_var(pio_file, 'dummy_val', PIO_TF_DATA_TYPE, (/pio_dim/), pio_var)
    PIO_TF_CHECK_ERR(ret, "Failed to define var:" // trim(filename))

    ret = PIO_def_var(pio_file, 'dummy_cval', PIO_char, (/pio_dim/), pio_cvar)
    PIO_TF_CHECK_ERR(ret, "Failed to define char var:" // trim(filename))

    ret = PIO_put_att(pio_file, pio_var, 'dummy_att_val', pval);
    PIO_TF_CHECK_ERR(ret, "Failed to put attribute:" // trim(filename))

    ret = PIO_put_att(pio_file, pio_cvar, 'dummy_att_cval', pcval);
    PIO_TF_CHECK_ERR(ret, "Failed to put char attribute:" // trim(filename))

    ret = PIO_enddef(pio_file)
    PIO_TF_CHECK_ERR(ret, "Failed to enddef:" // trim(filename))

#ifdef PIO_TEST_CLOSE_OPEN_FOR_SYNC
    call PIO_closefile(pio_file)

    ret = PIO_openfile(pio_tf_iosystem_, pio_file, iotypes(i), filename, PIO_nowrite)
    PIO_TF_CHECK_ERR(ret, "Could not reopen file " // trim(filename))

    ret = PIO_inq_varid(pio_file, 'dummy_val', pio_var)
    PIO_TF_CHECK_ERR(ret, "Could not inq var :" // trim(filename))

    ret = PIO_inq_varid(pio_file, 'dummy_cval', pio_cvar)
    PIO_TF_CHECK_ERR(ret, "Could not inq var :" // trim(filename))
#else
    call PIO_syncfile(pio_file)
#endif

    ret = PIO_get_att(pio_file, pio_var, 'dummy_att_val', gval);
    PIO_TF_CHECK_ERR(ret, "Failed to get attribute:" // trim(filename))

    PIO_TF_CHECK_VAL((gval, init_val), "Got wrong value")

    ! FIXME: Check the values are correct
    ret = PIO_get_att(pio_file, pio_cvar, 'dummy_att_cval', gcval);
    PIO_TF_CHECK_ERR(ret, "Failed to get attribute:" // trim(filename))

    call PIO_closefile(pio_file)
    call PIO_deletefile(pio_tf_iosystem_, filename);
  end do
  if(allocated(iotypes)) then
    deallocate(iotypes)
    deallocate(iotype_descs)
  end if

PIO_TF_AUTO_TEST_SUB_END test_put_get_1datt

PIO_TF_TEMPLATE<PIO_TF_PREDEF_TYPENAME PIO_TF_DATA_TYPE, PIO_TF_PREDEF_TYPENAME PIO_TF_FC_DATA_TYPE>
PIO_TF_AUTO_TEST_SUB_BEGIN test_put_get_0dvar
  Implicit none
  type(file_desc_t) :: pio_file
  character(len=PIO_TF_MAX_STR_LEN) :: filename
  type(var_desc_t)  :: pio_var, pio_cvar
  PIO_TF_FC_DATA_TYPE, dimension(1) :: pval, gval
  CHARACTER(len=1) :: pcval, gcval
  integer, dimension(:), allocatable :: iotypes
  character(len=PIO_TF_MAX_STR_LEN), dimension(:), allocatable :: iotype_descs
  character(len=*), parameter :: PIO_VAR_NAME = 'dummy_scalar_var_put_val'
  character(len=*), parameter :: PIO_CVAR_NAME = 'dummy_scalar_var_put_cval'
  integer :: num_iotypes
  integer :: i, ret
  
  pval = pio_tf_world_sz_
  pcval = "D"
  num_iotypes = 0
  call PIO_TF_Get_nc_iotypes(iotypes, iotype_descs, num_iotypes)
  filename = "test_pio_ncdf_get_put.testfile"
  do i=1,num_iotypes
    PIO_TF_LOG(0,*) "Testing type :", iotype_descs(i)
    ret = PIO_createfile(pio_tf_iosystem_, pio_file, iotypes(i), filename, PIO_CLOBBER)
    PIO_TF_CHECK_ERR(ret, "Failed to open:" // trim(filename))

    ! Since file is just created no need to enter redef
    ret = PIO_def_var(pio_file, PIO_VAR_NAME, PIO_TF_DATA_TYPE, pio_var)
    PIO_TF_CHECK_ERR(ret, "Failed to define scalar var:" // trim(filename))

    ret = PIO_def_var(pio_file, PIO_CVAR_NAME, PIO_char, pio_cvar)
    PIO_TF_CHECK_ERR(ret, "Failed to define scalar char var:" // trim(filename))

    ret = PIO_enddef(pio_file)
    PIO_TF_CHECK_ERR(ret, "Failed to enddef:" // trim(filename))

    ret = PIO_put_var(pio_file, pio_var, pval);
    PIO_TF_CHECK_ERR(ret, "Failed to put scalar var:" // trim(filename))

    ret = PIO_put_var(pio_file, pio_cvar, pcval);
    PIO_TF_CHECK_ERR(ret, "Failed to put scalar char var:" // trim(filename))

#ifdef PIO_TEST_CLOSE_OPEN_FOR_SYNC
    call PIO_closefile(pio_file)

    ret = PIO_openfile(pio_tf_iosystem_, pio_file, iotypes(i), filename, PIO_nowrite)
    PIO_TF_CHECK_ERR(ret, "Failed to reopen:" // trim(filename))

    ret = PIO_inq_varid(pio_file, PIO_VAR_NAME, pio_var)
    PIO_TF_CHECK_ERR(ret, "Failed to get scalar var:" // trim(filename))

    ret = PIO_inq_varid(pio_file, PIO_CVAR_NAME, pio_cvar)
    PIO_TF_CHECK_ERR(ret, "Failed to get scalar char var:" // trim(filename))
#else
    call PIO_syncfile(pio_file)
#endif

    ret = PIO_get_var(pio_file, pio_var, gval);
    PIO_TF_CHECK_ERR(ret, "Failed to get scalar var:" // trim(filename))

    PIO_TF_CHECK_VAL((gval, pval), "Got wrong value")

    ret = PIO_get_var(pio_file, pio_cvar, gcval);
    PIO_TF_CHECK_ERR(ret, "Failed to get scalar char var:" // trim(filename))

    PIO_TF_CHECK_VAL((gcval, pcval), "Got wrong value")

    call PIO_closefile(pio_file)
    call PIO_deletefile(pio_tf_iosystem_, filename);
  end do
  if(allocated(iotypes)) then
    deallocate(iotypes)
    deallocate(iotype_descs)
  end if

PIO_TF_AUTO_TEST_SUB_END test_put_get_0dvar

PIO_TF_TEMPLATE<PIO_TF_PREDEF_TYPENAME PIO_TF_DATA_TYPE, PIO_TF_PREDEF_TYPENAME PIO_TF_FC_DATA_TYPE>
PIO_TF_AUTO_TEST_SUB_BEGIN test_put_get_1dvar
  Implicit none
  type(file_desc_t) :: pio_file
  character(len=PIO_TF_MAX_STR_LEN) :: filename
  type(var_desc_t)  :: pio_var, pio_cvar
  integer :: pio_dim
  integer, parameter :: DIM_LEN = 100
  PIO_TF_FC_DATA_TYPE, dimension(DIM_LEN) :: pval, gval
  CHARACTER(len=DIM_LEN) :: pcval, gcval
  integer, dimension(:), allocatable :: iotypes
  character(len=PIO_TF_MAX_STR_LEN), dimension(:), allocatable :: iotype_descs
  character(len=*), parameter :: PIO_VAR_NAME = 'dummy_var_put_val'
  character(len=*), parameter :: PIO_CVAR_NAME = 'dummy_var_put_cval'
  integer :: num_iotypes
  integer :: i, ret
  
  pval = pio_tf_world_sz_
  pcval = "DUMMY_STRING"
  num_iotypes = 0
  call PIO_TF_Get_nc_iotypes(iotypes, iotype_descs, num_iotypes)
  filename = "test_pio_ncdf_get_put.testfile"
  do i=1,num_iotypes
    PIO_TF_LOG(0,*) "Testing type :", iotype_descs(i)
    ret = PIO_createfile(pio_tf_iosystem_, pio_file, iotypes(i), filename, PIO_CLOBBER)
    PIO_TF_CHECK_ERR(ret, "Failed to open:" // trim(filename))

    ! Since file is just created no need to enter redef
    ret = PIO_def_dim(pio_file, 'dummy_dim_put_val', DIM_LEN, pio_dim)
    PIO_TF_CHECK_ERR(ret, "Failed to define dim:" // trim(filename))

    ret = PIO_def_var(pio_file, PIO_VAR_NAME, PIO_TF_DATA_TYPE, (/pio_dim/), pio_var)
    PIO_TF_CHECK_ERR(ret, "Failed to define var:" // trim(filename))

    ret = PIO_def_var(pio_file, PIO_CVAR_NAME, PIO_char, (/pio_dim/), pio_cvar)
    PIO_TF_CHECK_ERR(ret, "Failed to define char var:" // trim(filename))

    ret = PIO_enddef(pio_file)
    PIO_TF_CHECK_ERR(ret, "Failed to enddef:" // trim(filename))

    ret = PIO_put_var(pio_file, pio_var, pval);
    PIO_TF_CHECK_ERR(ret, "Failed to put var:" // trim(filename))

    ret = PIO_put_var(pio_file, pio_cvar, pcval);
    PIO_TF_CHECK_ERR(ret, "Failed to put char var:" // trim(filename))

#ifdef PIO_TEST_CLOSE_OPEN_FOR_SYNC
    call PIO_closefile(pio_file)

    ret = PIO_openfile(pio_tf_iosystem_, pio_file, iotypes(i), filename, PIO_nowrite)
    PIO_TF_CHECK_ERR(ret, "Failed to reopen:" // trim(filename))

    ret = PIO_inq_varid(pio_file, PIO_VAR_NAME, pio_var)
    PIO_TF_CHECK_ERR(ret, "Failed to get scalar var:" // trim(filename))

    ret = PIO_inq_varid(pio_file, PIO_CVAR_NAME, pio_cvar)
    PIO_TF_CHECK_ERR(ret, "Failed to get scalar char var:" // trim(filename))
#else
    call PIO_syncfile(pio_file)
#endif

    ret = PIO_get_var(pio_file, pio_var, gval);
    PIO_TF_CHECK_ERR(ret, "Failed to get var:" // trim(filename))

    PIO_TF_CHECK_VAL((gval, pval), "Got wrong value")

    ret = PIO_get_var(pio_file, pio_cvar, gcval);
    PIO_TF_CHECK_ERR(ret, "Failed to get char var:" // trim(filename))

    PIO_TF_CHECK_VAL((gcval, pcval), "Got wrong value")

    call PIO_closefile(pio_file)
    call PIO_deletefile(pio_tf_iosystem_, filename);
  end do
  if(allocated(iotypes)) then
    deallocate(iotypes)
    deallocate(iotype_descs)
  end if

PIO_TF_AUTO_TEST_SUB_END test_put_get_1dvar

! Put and get variables with large/small (compared to the variable size) user buffers
PIO_TF_TEMPLATE<PIO_TF_PREDEF_TYPENAME PIO_TF_DATA_TYPE, PIO_TF_PREDEF_TYPENAME PIO_TF_FC_DATA_TYPE>
PIO_TF_AUTO_TEST_SUB_BEGIN test_put_get_1dvar_ls_buf
  Implicit none
  type(file_desc_t) :: pio_file
  character(len=PIO_TF_MAX_STR_LEN) :: filename
  type(var_desc_t)  :: pio_var, pio_cvar
  integer :: pio_dim

  integer, parameter :: DIM_LEN = 200
  integer, parameter :: DIM_LARGE_LEN = DIM_LEN + 100
  integer, parameter :: DIM_SMALL_LEN = DIM_LEN - 100
  ! User buffer to put/get the value is larger than the variable dim
  PIO_TF_FC_DATA_TYPE, dimension(DIM_LARGE_LEN) :: lpval, lgval
  CHARACTER(len=DIM_LARGE_LEN) :: lpcval, lgcval
  ! User buffer to put the value is smaller than the variable dim
  PIO_TF_FC_DATA_TYPE, dimension(DIM_SMALL_LEN) :: spval
  CHARACTER(len=DIM_SMALL_LEN) :: spcval

  integer, dimension(:), allocatable :: iotypes
  character(len=PIO_TF_MAX_STR_LEN), dimension(:), allocatable :: iotype_descs
  character(len=*), parameter :: PIO_VAR_NAME = 'dummy_var_put_val'
  character(len=*), parameter :: PIO_CVAR_NAME = 'dummy_var_put_cval'
  integer :: num_iotypes
  integer :: i, j, ret

  ! Initialize the part of the user buffer written out to the file
  do i=1,DIM_SMALL_LEN
    spval(i) = i
    spcval(i:i) = 's'
  end do

  ! Initialize the part of the user buffer written out to the file
  do i=1,DIM_LEN
    lpval(i) = i
    lpcval(i:i) = 'l'
  end do

  ! Initialize the part of get/put user buffers not read_from/written_to the file
  do i=DIM_LEN+1,DIM_LARGE_LEN
    lpval(i) = pio_tf_world_sz_
    ! Note : For strings the entire get buffer gets initialized by Scorpio, so
    ! any prior contents in the get buffer is erased. So any non-space character
    ! that is assigned to gcval(i:i) will be overwritten by Scorpio
    lpcval(i:i) = ''
    lgval(i) = lpval(i)
    lgcval(i:i) = lpcval(i:i)
  end do

  num_iotypes = 0
  call PIO_TF_Get_nc_iotypes(iotypes, iotype_descs, num_iotypes)
  filename = "test_pio_ncdf_get_put.testfile"
  do i=1,num_iotypes
    PIO_TF_LOG(0,*) "Testing type :", iotype_descs(i)
    ret = PIO_createfile(pio_tf_iosystem_, pio_file, iotypes(i), filename, PIO_CLOBBER)
    PIO_TF_CHECK_ERR(ret, "Failed to open:" // trim(filename))

    ! Since file is just created no need to enter redef
    ret = PIO_def_dim(pio_file, 'dummy_dim_put_val', DIM_LEN, pio_dim)
    PIO_TF_CHECK_ERR(ret, "Failed to define dim:" // trim(filename))

    ret = PIO_def_var(pio_file, PIO_VAR_NAME, PIO_TF_DATA_TYPE, (/pio_dim/), pio_var)
    PIO_TF_CHECK_ERR(ret, "Failed to define var:" // trim(filename))

    ret = PIO_def_var(pio_file, PIO_CVAR_NAME, PIO_char, (/pio_dim/), pio_cvar)
    PIO_TF_CHECK_ERR(ret, "Failed to define char var:" // trim(filename))

    ret = PIO_enddef(pio_file)
    PIO_TF_CHECK_ERR(ret, "Failed to enddef:" // trim(filename))

    ! Put and get the values using a user buffer that is larger than the
    ! variable
    ret = PIO_put_var(pio_file, pio_var, lpval);
    PIO_TF_CHECK_ERR(ret, "Failed to put var:" // trim(filename))

    ret = PIO_put_var(pio_file, pio_cvar, lpcval);
    PIO_TF_CHECK_ERR(ret, "Failed to put char var:" // trim(filename))

#ifdef PIO_TEST_CLOSE_OPEN_FOR_SYNC
    call PIO_closefile(pio_file)

    ret = PIO_openfile(pio_tf_iosystem_, pio_file, iotypes(i), filename, PIO_write)
    PIO_TF_CHECK_ERR(ret, "Failed to reopen:" // trim(filename))

    ret = PIO_inq_varid(pio_file, PIO_VAR_NAME, pio_var)
    PIO_TF_CHECK_ERR(ret, "Failed to get scalar var:" // trim(filename))

    ret = PIO_inq_varid(pio_file, PIO_CVAR_NAME, pio_cvar)
    PIO_TF_CHECK_ERR(ret, "Failed to get scalar char var:" // trim(filename))
#else
    call PIO_syncfile(pio_file)
#endif

    ret = PIO_get_var(pio_file, pio_var, lgval);
    PIO_TF_CHECK_ERR(ret, "Failed to get var:" // trim(filename))

    PIO_TF_CHECK_VAL((lgval, lpval), "Get with large user buffer : Got wrong value")

    ret = PIO_get_var(pio_file, pio_cvar, lgcval);
    PIO_TF_CHECK_ERR(ret, "Failed to get char var:" // trim(filename))

    PIO_TF_CHECK_VAL((lgcval, lpcval), "Get with large user buffer : Got wrong value")

    ! Put the values using a user buffer that is smaller than the
    ! variable and get it with a larger buffer
    ret = PIO_put_var(pio_file, pio_var, spval);
    PIO_TF_CHECK_ERR(ret, "Failed to put var:" // trim(filename))

    ret = PIO_put_var(pio_file, pio_cvar, spcval);
    PIO_TF_CHECK_ERR(ret, "Failed to put char var:" // trim(filename))

#ifdef PIO_TEST_CLOSE_OPEN_FOR_SYNC
    call PIO_closefile(pio_file)

    ret = PIO_openfile(pio_tf_iosystem_, pio_file, iotypes(i), filename, PIO_nowrite)
    PIO_TF_CHECK_ERR(ret, "Failed to reopen:" // trim(filename))

    ret = PIO_inq_varid(pio_file, PIO_VAR_NAME, pio_var)
    PIO_TF_CHECK_ERR(ret, "Failed to get scalar var:" // trim(filename))

    ret = PIO_inq_varid(pio_file, PIO_CVAR_NAME, pio_cvar)
    PIO_TF_CHECK_ERR(ret, "Failed to get scalar char var:" // trim(filename))
#else
    call PIO_syncfile(pio_file)
#endif

  do j=1,DIM_SMALL_LEN
    lpcval(j:j) = spcval(j:j)
  end do

  ! Since only values in spval and spcval, i.e., <= DIM_SMALL_LEN, is written
  ! out initialize the rest of the values in the buffer used to read the data
  ! and compare
  do j=DIM_SMALL_LEN+1,DIM_LARGE_LEN
    lpval(j) = 0
    ! Note : For strings the entire get buffer gets initialized by Scorpio, so
    ! any prior contents in the get buffer is erased. So any non-space character
    ! that is assigned to gcval(i:i) will be overwritten by Scorpio
    lpcval(j:j) = ''
    lgval(j) = lpval(j)
    lgcval(j:j) = lpcval(j:j)
  end do

    ! Note: Getting a variable with a buffer smaller than the size of the variable
    ! is an error, so use a large buffer for reading this data
    ret = PIO_get_var(pio_file, pio_var, lgval);
    PIO_TF_CHECK_ERR(ret, "Failed to get var:" // trim(filename))

    PIO_TF_CHECK_VAL((lgval, lpval), "Get with large user buffer : Got wrong value")

    ret = PIO_get_var(pio_file, pio_cvar, lgcval);
    PIO_TF_CHECK_ERR(ret, "Failed to get char var:" // trim(filename))

    ! Since the variable is written out with a smaller buffer (than the size of the
    ! variable), the rest of the variable might contain invalid/uninitialized
    ! values. Reset these values, that were not written out, before checking the
    ! results
    lgcval(DIM_SMALL_LEN+1:DIM_LARGE_LEN) = ''

    PIO_TF_CHECK_VAL((lgcval, lpcval), "Get with large user buffer : Got wrong value")

    call PIO_closefile(pio_file)
    call PIO_deletefile(pio_tf_iosystem_, filename);
  end do
  if(allocated(iotypes)) then
    deallocate(iotypes)
    deallocate(iotype_descs)
  end if

PIO_TF_AUTO_TEST_SUB_END test_put_get_1dvar_ls_buf

! Write out a 1d var slice from a 2d var
PIO_TF_TEMPLATE<PIO_TF_PREDEF_TYPENAME PIO_TF_DATA_TYPE, PIO_TF_PREDEF_TYPENAME PIO_TF_FC_DATA_TYPE>
PIO_TF_AUTO_TEST_SUB_BEGIN test_put_get_1dvar_slice
  Implicit none
  type(file_desc_t) :: pio_file
  character(len=PIO_TF_MAX_STR_LEN) :: filename
  character(len=*), parameter :: PIO_VAR_NAME = 'dummy_var_put_val'
  type(var_desc_t)  :: pio_var
  integer :: pio_dim
  integer, parameter :: MAX_ROW_DIM_LEN = 100
  PIO_TF_FC_DATA_TYPE, dimension(MAX_ROW_DIM_LEN) :: gval, exp_val
  integer, parameter :: MAX_COL_DIM_LEN = 4
  ! Only COL_WRITE_DIM of MAX_COL_DIM_LEN columns in pval is written out
  integer, parameter :: COL_WRITE_DIM = 2
  PIO_TF_FC_DATA_TYPE, dimension(MAX_ROW_DIM_LEN, MAX_COL_DIM_LEN) :: pval
  integer, dimension(:) :: start(4), count(4)
  integer, dimension(:), allocatable :: iotypes
  character(len=PIO_TF_MAX_STR_LEN), dimension(:), allocatable :: iotype_descs
  integer :: num_iotypes
  integer :: i, ret
  
  pval = -1
  pval(:,COL_WRITE_DIM) = pio_tf_world_sz_
  exp_val = pio_tf_world_sz_
  start = 0
  count = 0
  start(1) = 1
  count(1) = MAX_ROW_DIM_LEN
  num_iotypes = 0
  call PIO_TF_Get_nc_iotypes(iotypes, iotype_descs, num_iotypes)
  filename = "test_pio_ncdf_get_put_slice.testfile"
  do i=1,num_iotypes
    PIO_TF_LOG(0,*) "Testing type :", iotype_descs(i)
    ret = PIO_createfile(pio_tf_iosystem_, pio_file, iotypes(i), filename, PIO_CLOBBER)
    PIO_TF_CHECK_ERR(ret, "Failed to open:" // trim(filename))

    ! Since file is just created no need to enter redef
    ret = PIO_def_dim(pio_file, 'dummy_dim_put_val', MAX_ROW_DIM_LEN, pio_dim)
    PIO_TF_CHECK_ERR(ret, "Failed to define dim:" // trim(filename))

    ret = PIO_def_var(pio_file, PIO_VAR_NAME, PIO_TF_DATA_TYPE, (/pio_dim/), pio_var)
    PIO_TF_CHECK_ERR(ret, "Failed to define var:" // trim(filename))

    ret = PIO_enddef(pio_file)
    PIO_TF_CHECK_ERR(ret, "Failed to enddef:" // trim(filename))

    ret = PIO_put_var(pio_file, pio_var, start, count, pval(:,COL_WRITE_DIM));
    PIO_TF_CHECK_ERR(ret, "Failed to put var:" // trim(filename))

#ifdef PIO_TEST_CLOSE_OPEN_FOR_SYNC
    call PIO_closefile(pio_file)

    ret = PIO_openfile(pio_tf_iosystem_, pio_file, iotypes(i), filename, PIO_nowrite)
    PIO_TF_CHECK_ERR(ret, "Failed to reopen:" // trim(filename))

    ret = PIO_inq_varid(pio_file, PIO_VAR_NAME, pio_var)
    PIO_TF_CHECK_ERR(ret, "Failed to get scalar var:" // trim(filename))
#else
    call PIO_syncfile(pio_file)
#endif

    ret = PIO_get_var(pio_file, pio_var, gval);
    PIO_TF_CHECK_ERR(ret, "Failed to get var:" // trim(filename))

    PIO_TF_CHECK_VAL((gval, exp_val), "Got wrong value")

    call PIO_closefile(pio_file)
    call PIO_deletefile(pio_tf_iosystem_, filename);
  end do
  if(allocated(iotypes)) then
    deallocate(iotypes)
    deallocate(iotype_descs)
  end if

PIO_TF_AUTO_TEST_SUB_END test_put_get_1dvar_slice

PIO_TF_TEMPLATE<PIO_TF_PREDEF_TYPENAME PIO_TF_DATA_TYPE, PIO_TF_PREDEF_TYPENAME PIO_TF_FC_DATA_TYPE>
PIO_TF_AUTO_TEST_SUB_BEGIN test_put_get_1dvar_4parts
  Implicit none
  type(file_desc_t) :: pio_file
  character(len=PIO_TF_MAX_STR_LEN) :: filename
  character(len=*), parameter :: PIO_VAR_NAME = 'dummy_var_put_val'
  type(var_desc_t)  :: pio_var
  integer :: pio_dim
  integer, parameter :: DIM_LEN = 16
  integer, parameter :: PART_LEN = DIM_LEN / 4
  PIO_TF_FC_DATA_TYPE, dimension(DIM_LEN) :: pval, gval
  integer, dimension(:), allocatable :: iotypes
  character(len=PIO_TF_MAX_STR_LEN), dimension(:), allocatable :: iotype_descs
  integer :: num_iotypes
  integer :: i, ret
  integer, dimension(1) :: start, count = PART_LEN
  
  do i=1,DIM_LEN
    pval(i) = i
  end do
  num_iotypes = 0
  call PIO_TF_Get_nc_iotypes(iotypes, iotype_descs, num_iotypes)
  filename = "test_pio_ncdf_get_put.testfile"
  do i=1,num_iotypes
    PIO_TF_LOG(0,*) "Testing type :", iotype_descs(i)
    ret = PIO_createfile(pio_tf_iosystem_, pio_file, iotypes(i), filename, PIO_CLOBBER)
    PIO_TF_CHECK_ERR(ret, "Failed to open:" // trim(filename))

    ! Since file is just created no need to enter redef
    ret = PIO_def_dim(pio_file, 'dummy_dim_put_val', DIM_LEN, pio_dim)
    PIO_TF_CHECK_ERR(ret, "Failed to define dim:" // trim(filename))

    ret = PIO_def_var(pio_file, PIO_VAR_NAME, PIO_TF_DATA_TYPE, (/pio_dim/), pio_var)
    PIO_TF_CHECK_ERR(ret, "Failed to define var:" // trim(filename))

    ret = PIO_enddef(pio_file)
    PIO_TF_CHECK_ERR(ret, "Failed to enddef:" // trim(filename))

    start = 1
    ret = PIO_put_var(pio_file, pio_var, start, count, pval(1 : PART_LEN))
    PIO_TF_CHECK_ERR(ret, "Failed to put var (1st part):" // trim(filename))

    start = PART_LEN + 1
    ret = PIO_put_var(pio_file, pio_var, start, count, pval(PART_LEN + 1 : PART_LEN * 2))
    PIO_TF_CHECK_ERR(ret, "Failed to put var (2nd part):" // trim(filename))

    start = PART_LEN * 2 + 1
    ret = PIO_put_var(pio_file, pio_var, start, count, pval(PART_LEN * 2 + 1 : PART_LEN * 3))
    PIO_TF_CHECK_ERR(ret, "Failed to put var (3rd part):" // trim(filename))

    start = PART_LEN * 3 + 1
    ret = PIO_put_var(pio_file, pio_var, start, count, pval(PART_LEN * 3 + 1 : DIM_LEN))
    PIO_TF_CHECK_ERR(ret, "Failed to put var (4th part):" // trim(filename))

#ifdef PIO_TEST_CLOSE_OPEN_FOR_SYNC
    call PIO_closefile(pio_file)

    ret = PIO_openfile(pio_tf_iosystem_, pio_file, iotypes(i), filename, PIO_nowrite)
    PIO_TF_CHECK_ERR(ret, "Failed to reopen:" // trim(filename))

    ret = PIO_inq_varid(pio_file, PIO_VAR_NAME, pio_var)
    PIO_TF_CHECK_ERR(ret, "Failed to get scalar var:" // trim(filename))
#else
    call PIO_syncfile(pio_file)
#endif

    start = PART_LEN * 3 + 1
    ret = PIO_get_var(pio_file, pio_var, start, count, gval(PART_LEN * 3 + 1 : DIM_LEN))
    PIO_TF_CHECK_ERR(ret, "Failed to get var (4th part):" // trim(filename))

    start = PART_LEN * 2 + 1
    ret = PIO_get_var(pio_file, pio_var, start, count, gval(PART_LEN * 2 + 1 : PART_LEN * 3))
    PIO_TF_CHECK_ERR(ret, "Failed to get var (3rd part):" // trim(filename))

    start = PART_LEN + 1
    ret = PIO_get_var(pio_file, pio_var, start, count, gval(PART_LEN + 1 : PART_LEN * 2))
    PIO_TF_CHECK_ERR(ret, "Failed to get var (2nd part):" // trim(filename))

    start = 1
    ret = PIO_get_var(pio_file, pio_var, start, count, gval(1 : PART_LEN))
    PIO_TF_CHECK_ERR(ret, "Failed to get var (1st part):" // trim(filename))

    PIO_TF_CHECK_VAL((gval, pval), "Got wrong value")

    call PIO_closefile(pio_file)
    call PIO_deletefile(pio_tf_iosystem_, filename);
  end do
  if(allocated(iotypes)) then
    deallocate(iotypes)
    deallocate(iotype_descs)
  end if

PIO_TF_AUTO_TEST_SUB_END test_put_get_1dvar_4parts

! Write out 2d/3d/4d vars, one time slice at a time
PIO_TF_TEMPLATE<PIO_TF_PREDEF_TYPENAME PIO_TF_DATA_TYPE, PIO_TF_PREDEF_TYPENAME PIO_TF_FC_DATA_TYPE>
PIO_TF_AUTO_TEST_SUB_BEGIN test_put_get_md2mdplus1_var
  Implicit none
  type(file_desc_t) :: pio_file
  character(len=PIO_TF_MAX_STR_LEN) :: filename
  character(len=*), parameter :: PIO_2DVAR_NAME = '2d_val'
  character(len=*), parameter :: PIO_3DVAR_NAME = '3d_val'
  character(len=*), parameter :: PIO_4DVAR_NAME = '4d_val'
  integer, parameter :: MAX_DIMS = 4
  integer, parameter :: MAX_ROWS = 10
  integer, parameter :: MAX_COLS = 10
  integer, parameter :: MAX_LEVS = 3
  integer, parameter :: MAX_TIMES = 3
  integer, dimension(MAX_DIMS) :: pio_dims
  type(var_desc_t)  :: pio_2dvar, pio_3dvar, pio_4dvar
  PIO_TF_FC_DATA_TYPE, dimension(MAX_ROWS,MAX_TIMES) :: gval_2d, exp_val_2d
  PIO_TF_FC_DATA_TYPE, dimension(MAX_ROWS,MAX_COLS,MAX_TIMES) :: gval_3d, exp_val_3d
  PIO_TF_FC_DATA_TYPE, dimension(MAX_ROWS,MAX_COLS,MAX_LEVS,MAX_TIMES) ::&
                                                      gval_4d, exp_val_4d
  ! Only one slice is written out at a time
  ! pval_1d is a 1d slice of gval_2d ...
  PIO_TF_FC_DATA_TYPE, dimension(MAX_ROWS) :: pval_1d
  PIO_TF_FC_DATA_TYPE, dimension(MAX_ROWS, MAX_COLS) :: pval_2d
  PIO_TF_FC_DATA_TYPE, dimension(MAX_ROWS, MAX_COLS, MAX_LEVS) :: pval_3d
  integer, dimension(:) :: start(MAX_DIMS), count(MAX_DIMS)
  integer :: pval_start
  integer, dimension(:), allocatable :: iotypes
  character(len=PIO_TF_MAX_STR_LEN), dimension(:), allocatable :: iotype_descs
  integer :: num_iotypes
  integer :: i, k, l, m, tstep, ret
  
  num_iotypes = 0
  call PIO_TF_Get_nc_iotypes(iotypes, iotype_descs, num_iotypes)
  filename = "test_pio_ncdf_get_put_md_slice.testfile"
  do i=1,num_iotypes
    PIO_TF_LOG(0,*) "Testing type :", iotype_descs(i)
    ret = PIO_createfile(pio_tf_iosystem_, pio_file, iotypes(i), filename, PIO_CLOBBER)
    PIO_TF_CHECK_ERR(ret, "Failed to open:" // trim(filename))

    ! Since file is just created no need to enter redef
    ret = PIO_def_dim(pio_file, 'nrows', MAX_ROWS, pio_dims(1))
    PIO_TF_CHECK_ERR(ret, "Failed to define dim:" // trim(filename))

    ret = PIO_def_dim(pio_file, 'ncols', MAX_COLS, pio_dims(2))
    PIO_TF_CHECK_ERR(ret, "Failed to define dim:" // trim(filename))

    ret = PIO_def_dim(pio_file, 'nlevs', MAX_LEVS, pio_dims(3))
    PIO_TF_CHECK_ERR(ret, "Failed to define dim:" // trim(filename))

    ret = PIO_def_dim(pio_file, 'timesteps', MAX_TIMES, pio_dims(4))
    PIO_TF_CHECK_ERR(ret, "Failed to define dim:" // trim(filename))

    ret = PIO_def_var(pio_file, PIO_2DVAR_NAME, PIO_TF_DATA_TYPE,&
              (/pio_dims(1),pio_dims(4)/), pio_2dvar)
    PIO_TF_CHECK_ERR(ret, "Failed to define var:" // trim(filename))

    ret = PIO_def_var(pio_file, PIO_3DVAR_NAME, PIO_TF_DATA_TYPE,&
              (/pio_dims(1),pio_dims(2),pio_dims(4)/), pio_3dvar)
    PIO_TF_CHECK_ERR(ret, "Failed to define var:" // trim(filename))

    ret = PIO_def_var(pio_file, PIO_4DVAR_NAME, PIO_TF_DATA_TYPE,&
              pio_dims, pio_4dvar)
    PIO_TF_CHECK_ERR(ret, "Failed to define var:" // trim(filename))

    ret = PIO_enddef(pio_file)
    PIO_TF_CHECK_ERR(ret, "Failed to enddef:" // trim(filename))

    ! Put vals are for each timestep &
    ! expected vals are combined for all timesteps
    do k=1,MAX_ROWS
      pval_1d(k) = k
    end do
    do tstep=1,MAX_TIMES
      pval_start = (tstep - 1) * MAX_ROWS
      exp_val_2d(:,tstep) = pval_1d + pval_start
    end do
    do l=1,MAX_COLS
      do k=1,MAX_ROWS
        pval_2d(k,l) = (l - 1)*MAX_ROWS + k
      end do
    end do
    do tstep=1,MAX_TIMES
      do l=1,MAX_COLS
        do k=1,MAX_ROWS
          pval_start = (tstep - 1) * (MAX_ROWS * MAX_COLS)
          exp_val_3d(:,:,tstep) = pval_2d + pval_start
        end do
      end do
    end do
    do m=1,MAX_LEVS
      do l=1,MAX_COLS
        do k=1,MAX_ROWS
          pval_3d(k,l,m) = ((m-1)*(MAX_COLS*MAX_ROWS)+(l - 1)*MAX_ROWS + k)
        end do
      end do
    end do
    do tstep=1,MAX_TIMES
      do m=1,MAX_LEVS
        do l=1,MAX_COLS
          do k=1,MAX_ROWS
            pval_start = (tstep - 1) * (MAX_ROWS * MAX_COLS * MAX_LEVS)
            exp_val_4d(:,:,:,tstep) = pval_3d + pval_start
          end do
        end do
      end do
    end do
    ! Put 2d/3d/4d vals, one timestep at a time
    do tstep=1,MAX_TIMES
      start = 0
      count = 0

      start(1) = 1
      count(1) = MAX_ROWS
      start(2) = tstep
      count(2) = 1
      pval_start = (tstep - 1) * MAX_ROWS
      ret = PIO_put_var(pio_file, pio_2dvar, start, count,&
              pval_1d(:)+pval_start)
      PIO_TF_CHECK_ERR(ret, "Failed to put 2d var:" // trim(filename))

      start(1) = 1
      count(1) = MAX_ROWS
      start(2) = 1
      count(2) = MAX_COLS
      start(3) = tstep
      count(3) = 1
      pval_start = (tstep - 1) * (MAX_ROWS * MAX_COLS)
      ret = PIO_put_var(pio_file, pio_3dvar, start, count,&
              pval_2d(:,:)+pval_start)
      PIO_TF_CHECK_ERR(ret, "Failed to put 3d var:" // trim(filename))

      start(1) = 1
      count(1) = MAX_ROWS
      start(2) = 1
      count(2) = MAX_COLS
      start(3) = 1
      count(3) = MAX_LEVS
      start(4) = tstep
      count(4) = 1
      pval_start = (tstep - 1) * (MAX_ROWS * MAX_COLS * MAX_LEVS)
      ret = PIO_put_var(pio_file, pio_4dvar, start, count,&
              pval_3d(:,:,:)+pval_start)
      PIO_TF_CHECK_ERR(ret, "Failed to put 4d var:" // trim(filename))
    end do

#ifdef PIO_TEST_CLOSE_OPEN_FOR_SYNC
    call PIO_closefile(pio_file)

    ret = PIO_openfile(pio_tf_iosystem_, pio_file, iotypes(i), filename, PIO_nowrite)
    PIO_TF_CHECK_ERR(ret, "Failed to reopen:" // trim(filename))

    ret = PIO_inq_varid(pio_file, PIO_2DVAR_NAME, pio_2dvar)
    PIO_TF_CHECK_ERR(ret, "Failed to inq 2d var" // trim(filename))

    ret = PIO_inq_varid(pio_file, PIO_3DVAR_NAME, pio_3dvar)
    PIO_TF_CHECK_ERR(ret, "Failed to inq 3d var" // trim(filename))

    ret = PIO_inq_varid(pio_file, PIO_4DVAR_NAME, pio_4dvar)
    PIO_TF_CHECK_ERR(ret, "Failed to inq 4d var" // trim(filename))
#else
    call PIO_syncfile(pio_file)
#endif

    ret = PIO_get_var(pio_file, pio_2dvar, gval_2d)
    PIO_TF_CHECK_ERR(ret, "Failed to get 2d var:" // trim(filename))

    PIO_TF_CHECK_VAL((gval_2d, exp_val_2d), "Got wrong value (2d var)")

    ret = PIO_get_var(pio_file, pio_3dvar, gval_3d)
    PIO_TF_CHECK_ERR(ret, "Failed to get 3d var:" // trim(filename))

    PIO_TF_CHECK_VAL((gval_3d, exp_val_3d), "Got wrong value (3d var)")

    ret = PIO_get_var(pio_file, pio_4dvar, gval_4d)
    PIO_TF_CHECK_ERR(ret, "Failed to get 4d var:" // trim(filename))

    ! Special code to handle 4d vals is required since the framework
    ! currently does not support comparing 4d arrays
    do tstep=1,MAX_TIMES
      PIO_TF_CHECK_VAL((gval_4d(:,:,:,tstep), exp_val_4d(:,:,:,tstep)), "Got wrong value (4d var)")
    end do

    call PIO_closefile(pio_file)
    call PIO_deletefile(pio_tf_iosystem_, filename);
  end do
  if(allocated(iotypes)) then
    deallocate(iotypes)
    deallocate(iotype_descs)
  end if

PIO_TF_AUTO_TEST_SUB_END test_put_get_md2mdplus1_var

! Similar to test_put_get_md2mdplus1_var, but uses an unlimited time dimension instead
PIO_TF_TEMPLATE<PIO_TF_PREDEF_TYPENAME PIO_TF_DATA_TYPE, PIO_TF_PREDEF_TYPENAME PIO_TF_FC_DATA_TYPE>
PIO_TF_AUTO_TEST_SUB_BEGIN test_put_get_md2mdplus1_rec
  Implicit none
  type(file_desc_t) :: pio_file
  character(len=PIO_TF_MAX_STR_LEN) :: filename
  character(len=*), parameter :: PIO_2DVAR_NAME = '2d_val'
  character(len=*), parameter :: PIO_3DVAR_NAME = '3d_val'
  character(len=*), parameter :: PIO_4DVAR_NAME = '4d_val'
  integer, parameter :: MAX_DIMS = 4
  integer, parameter :: MAX_ROWS = 10
  integer, parameter :: MAX_COLS = 10
  integer, parameter :: MAX_LEVS = 3
  integer, parameter :: MAX_TIMES = 3
  integer, dimension(MAX_DIMS) :: pio_dims
  type(var_desc_t)  :: pio_2dvar, pio_3dvar, pio_4dvar
  PIO_TF_FC_DATA_TYPE, dimension(MAX_ROWS,MAX_TIMES) :: gval_2d, exp_val_2d
  PIO_TF_FC_DATA_TYPE, dimension(MAX_ROWS,MAX_COLS,MAX_TIMES) :: gval_3d, exp_val_3d
  PIO_TF_FC_DATA_TYPE, dimension(MAX_ROWS,MAX_COLS,MAX_LEVS,MAX_TIMES) ::&
                                                      gval_4d, exp_val_4d
  ! Only one slice is written out at a time
  ! pval_1d is a 1d slice of gval_2d ...
  PIO_TF_FC_DATA_TYPE, dimension(MAX_ROWS) :: pval_1d
  PIO_TF_FC_DATA_TYPE, dimension(MAX_ROWS, MAX_COLS) :: pval_2d
  PIO_TF_FC_DATA_TYPE, dimension(MAX_ROWS, MAX_COLS, MAX_LEVS) :: pval_3d
  integer, dimension(:) :: start(MAX_DIMS), count(MAX_DIMS)
  integer :: pval_start
  integer, dimension(:), allocatable :: iotypes
  character(len=PIO_TF_MAX_STR_LEN), dimension(:), allocatable :: iotype_descs
  integer :: num_iotypes
  integer :: i, k, l, m, tstep, ret

  num_iotypes = 0
  call PIO_TF_Get_nc_iotypes(iotypes, iotype_descs, num_iotypes)
  filename = "test_pio_ncdf_get_put_md_slice_rec.testfile"
  do i=1,num_iotypes
    PIO_TF_LOG(0,*) "Testing type :", iotype_descs(i)
    ret = PIO_createfile(pio_tf_iosystem_, pio_file, iotypes(i), filename, PIO_CLOBBER)
    PIO_TF_CHECK_ERR(ret, "Failed to open:" // trim(filename))

    ! Since file is just created no need to enter redef
    ret = PIO_def_dim(pio_file, 'nrows', MAX_ROWS, pio_dims(1))
    PIO_TF_CHECK_ERR(ret, "Failed to define dim:" // trim(filename))

    ret = PIO_def_dim(pio_file, 'ncols', MAX_COLS, pio_dims(2))
    PIO_TF_CHECK_ERR(ret, "Failed to define dim:" // trim(filename))

    ret = PIO_def_dim(pio_file, 'nlevs', MAX_LEVS, pio_dims(3))
    PIO_TF_CHECK_ERR(ret, "Failed to define dim:" // trim(filename))

    ret = PIO_def_dim(pio_file, 'timesteps', pio_unlimited, pio_dims(4))
    PIO_TF_CHECK_ERR(ret, "Failed to define dim:" // trim(filename))

    ret = PIO_def_var(pio_file, PIO_2DVAR_NAME, PIO_TF_DATA_TYPE,&
              (/pio_dims(1),pio_dims(4)/), pio_2dvar)
    PIO_TF_CHECK_ERR(ret, "Failed to define var:" // trim(filename))

    ret = PIO_def_var(pio_file, PIO_3DVAR_NAME, PIO_TF_DATA_TYPE,&
              (/pio_dims(1),pio_dims(2),pio_dims(4)/), pio_3dvar)
    PIO_TF_CHECK_ERR(ret, "Failed to define var:" // trim(filename))

    ret = PIO_def_var(pio_file, PIO_4DVAR_NAME, PIO_TF_DATA_TYPE,&
              pio_dims, pio_4dvar)
    PIO_TF_CHECK_ERR(ret, "Failed to define var:" // trim(filename))

    ret = PIO_enddef(pio_file)
    PIO_TF_CHECK_ERR(ret, "Failed to enddef:" // trim(filename))

    ! Put vals are for each timestep &
    ! expected vals are combined for all timesteps
    do k=1,MAX_ROWS
      pval_1d(k) = k
    end do
    do tstep=1,MAX_TIMES
      pval_start = (tstep - 1) * MAX_ROWS
      exp_val_2d(:,tstep) = pval_1d + pval_start
    end do
    do l=1,MAX_COLS
      do k=1,MAX_ROWS
        pval_2d(k,l) = (l - 1)*MAX_ROWS + k
      end do
    end do
    do tstep=1,MAX_TIMES
      do l=1,MAX_COLS
        do k=1,MAX_ROWS
          pval_start = (tstep - 1) * (MAX_ROWS * MAX_COLS)
          exp_val_3d(:,:,tstep) = pval_2d + pval_start
        end do
      end do
    end do
    do m=1,MAX_LEVS
      do l=1,MAX_COLS
        do k=1,MAX_ROWS
          pval_3d(k,l,m) = ((m-1)*(MAX_COLS*MAX_ROWS)+(l - 1)*MAX_ROWS + k)
        end do
      end do
    end do
    do tstep=1,MAX_TIMES
      do m=1,MAX_LEVS
        do l=1,MAX_COLS
          do k=1,MAX_ROWS
            pval_start = (tstep - 1) * (MAX_ROWS * MAX_COLS * MAX_LEVS)
            exp_val_4d(:,:,:,tstep) = pval_3d + pval_start
          end do
        end do
      end do
    end do
    ! Put 2d/3d/4d vals, one timestep at a time
    do tstep=1,MAX_TIMES
      start = 0
      count = 0

      start(1) = 1
      count(1) = MAX_ROWS
      start(2) = tstep
      count(2) = 1
      pval_start = (tstep - 1) * MAX_ROWS
      ret = PIO_put_var(pio_file, pio_2dvar, start, count,&
              pval_1d(:)+pval_start)
      PIO_TF_CHECK_ERR(ret, "Failed to put 2d var:" // trim(filename))

      start(1) = 1
      count(1) = MAX_ROWS
      start(2) = 1
      count(2) = MAX_COLS
      start(3) = tstep
      count(3) = 1
      pval_start = (tstep - 1) * (MAX_ROWS * MAX_COLS)
      ret = PIO_put_var(pio_file, pio_3dvar, start, count,&
              pval_2d(:,:)+pval_start)
      PIO_TF_CHECK_ERR(ret, "Failed to put 3d var:" // trim(filename))

      start(1) = 1
      count(1) = MAX_ROWS
      start(2) = 1
      count(2) = MAX_COLS
      start(3) = 1
      count(3) = MAX_LEVS
      start(4) = tstep
      count(4) = 1
      pval_start = (tstep - 1) * (MAX_ROWS * MAX_COLS * MAX_LEVS)
      ret = PIO_put_var(pio_file, pio_4dvar, start, count,&
              pval_3d(:,:,:)+pval_start)
      PIO_TF_CHECK_ERR(ret, "Failed to put 4d var:" // trim(filename))
    end do

#ifdef PIO_TEST_CLOSE_OPEN_FOR_SYNC
    call PIO_closefile(pio_file)

    ret = PIO_openfile(pio_tf_iosystem_, pio_file, iotypes(i), filename, PIO_nowrite)
    PIO_TF_CHECK_ERR(ret, "Failed to reopen:" // trim(filename))

    ret = PIO_inq_varid(pio_file, PIO_2DVAR_NAME, pio_2dvar)
    PIO_TF_CHECK_ERR(ret, "Failed to inq 2d var" // trim(filename))

    ret = PIO_inq_varid(pio_file, PIO_3DVAR_NAME, pio_3dvar)
    PIO_TF_CHECK_ERR(ret, "Failed to inq 3d var" // trim(filename))

    ret = PIO_inq_varid(pio_file, PIO_4DVAR_NAME, pio_4dvar)
    PIO_TF_CHECK_ERR(ret, "Failed to inq 4d var" // trim(filename))
#else
    call PIO_syncfile(pio_file)
#endif

    ret = PIO_get_var(pio_file, pio_2dvar, gval_2d)
    PIO_TF_CHECK_ERR(ret, "Failed to get 2d var:" // trim(filename))

    PIO_TF_CHECK_VAL((gval_2d, exp_val_2d), "Got wrong value (2d var)")

    ret = PIO_get_var(pio_file, pio_3dvar, gval_3d)
    PIO_TF_CHECK_ERR(ret, "Failed to get 3d var:" // trim(filename))

    PIO_TF_CHECK_VAL((gval_3d, exp_val_3d), "Got wrong value (3d var)")

    ret = PIO_get_var(pio_file, pio_4dvar, gval_4d)
    PIO_TF_CHECK_ERR(ret, "Failed to get 4d var:" // trim(filename))

    ! Special code to handle 4d vals is required since the framework
    ! currently does not support comparing 4d arrays
    do tstep=1,MAX_TIMES
      PIO_TF_CHECK_VAL((gval_4d(:,:,:,tstep), exp_val_4d(:,:,:,tstep)), "Got wrong value (4d var)")
    end do

    call PIO_closefile(pio_file)
    call PIO_deletefile(pio_tf_iosystem_, filename);
  end do
  if(allocated(iotypes)) then
    deallocate(iotypes)
    deallocate(iotype_descs)
  end if

PIO_TF_AUTO_TEST_SUB_END test_put_get_md2mdplus1_rec

! Write out a scalar variable over time
PIO_TF_TEMPLATE<PIO_TF_PREDEF_TYPENAME PIO_TF_DATA_TYPE, PIO_TF_PREDEF_TYPENAME PIO_TF_FC_DATA_TYPE>
PIO_TF_AUTO_TEST_SUB_BEGIN test_put_get_time_scalar
  Implicit none
  type(file_desc_t) :: pio_file
  character(len=PIO_TF_MAX_STR_LEN) :: filename
  character(len=*), parameter :: PIO_VAR_NAME = 'dummy_scalar_var_over_time'
  integer, parameter :: MAX_TIMES = 3
  integer :: pio_dim
  type(var_desc_t)  :: pio_var
  PIO_TF_FC_DATA_TYPE, dimension(MAX_TIMES) :: gval, exp_val

  ! Only one slice is written out at a time
  PIO_TF_FC_DATA_TYPE, dimension(1) :: pval
  integer, dimension(:) :: start(1), count(1)
  integer, dimension(:), allocatable :: iotypes
  character(len=PIO_TF_MAX_STR_LEN), dimension(:), allocatable :: iotype_descs
  integer :: num_iotypes
  integer :: i, tstep, ret

  num_iotypes = 0
  call PIO_TF_Get_nc_iotypes(iotypes, iotype_descs, num_iotypes)
  filename = "test_pio_ncdf_get_put_time_scalar.testfile"
  do i=1,num_iotypes
    PIO_TF_LOG(0,*) "Testing type :", iotype_descs(i)
    ret = PIO_createfile(pio_tf_iosystem_, pio_file, iotypes(i), filename, PIO_CLOBBER)
    PIO_TF_CHECK_ERR(ret, "Failed to open:" // trim(filename))

    ! Since file is just created no need to enter redef
    ret = PIO_def_dim(pio_file, 'timesteps', MAX_TIMES, pio_dim)
    PIO_TF_CHECK_ERR(ret, "Failed to define dim:" // trim(filename))

    ret = PIO_def_var(pio_file, PIO_VAR_NAME, PIO_TF_DATA_TYPE, (/pio_dim/), pio_var)
    PIO_TF_CHECK_ERR(ret, "Failed to define var:" // trim(filename))

    ret = PIO_enddef(pio_file)
    PIO_TF_CHECK_ERR(ret, "Failed to enddef:" // trim(filename))

    ! Put scalar vals, one timestep at a time
    do tstep=1,MAX_TIMES
      start(1) = tstep
      count(1) = 1
      exp_val(tstep) = tstep - 1
      pval = tstep - 1
      ret = PIO_put_var(pio_file, pio_var, start, count, pval)
      PIO_TF_CHECK_ERR(ret, "Failed to put scalar var over time:" // trim(filename))
    end do

#ifdef PIO_TEST_CLOSE_OPEN_FOR_SYNC
    call PIO_closefile(pio_file)

    ret = PIO_openfile(pio_tf_iosystem_, pio_file, iotypes(i), filename, PIO_nowrite)
    PIO_TF_CHECK_ERR(ret, "Failed to reopen:" // trim(filename))

    ret = PIO_inq_varid(pio_file, PIO_VAR_NAME, pio_var)
    PIO_TF_CHECK_ERR(ret, "Failed to inq scalar var over time" // trim(filename))
#else
    call PIO_syncfile(pio_file)
#endif

    ret = PIO_get_var(pio_file, pio_var, gval)
    PIO_TF_CHECK_ERR(ret, "Failed to get scalar var over time:" // trim(filename))

    PIO_TF_CHECK_VAL((gval, exp_val), "Got wrong value (scalar var over time)")

    call PIO_closefile(pio_file)
    call PIO_deletefile(pio_tf_iosystem_, filename);
  end do

  if(allocated(iotypes)) then
    deallocate(iotypes)
    deallocate(iotype_descs)
  end if

PIO_TF_AUTO_TEST_SUB_END test_put_get_time_scalar

! Similar to test_put_get_time_scalar, but uses an unlimited time dimension instead
PIO_TF_TEMPLATE<PIO_TF_PREDEF_TYPENAME PIO_TF_DATA_TYPE, PIO_TF_PREDEF_TYPENAME PIO_TF_FC_DATA_TYPE>
PIO_TF_AUTO_TEST_SUB_BEGIN test_put_get_time_scalar_rec
  Implicit none
  type(file_desc_t) :: pio_file
  character(len=PIO_TF_MAX_STR_LEN) :: filename
  character(len=*), parameter :: PIO_VAR_NAME = 'dummy_scalar_var_over_time'
  integer, parameter :: MAX_TIMES = 3
  integer :: pio_dim
  type(var_desc_t)  :: pio_var
  PIO_TF_FC_DATA_TYPE, dimension(MAX_TIMES) :: gval, exp_val

  ! Only one slice is written out at a time
  PIO_TF_FC_DATA_TYPE, dimension(1) :: pval
  integer, dimension(:) :: start(1), count(1)
  integer, dimension(:), allocatable :: iotypes
  character(len=PIO_TF_MAX_STR_LEN), dimension(:), allocatable :: iotype_descs
  integer :: num_iotypes
  integer :: i, tstep, ret

  num_iotypes = 0
  call PIO_TF_Get_nc_iotypes(iotypes, iotype_descs, num_iotypes)
  filename = "test_pio_ncdf_get_put_time_scalar_rec.testfile"
  do i=1,num_iotypes
    PIO_TF_LOG(0,*) "Testing type :", iotype_descs(i)
    ret = PIO_createfile(pio_tf_iosystem_, pio_file, iotypes(i), filename, PIO_CLOBBER)
    PIO_TF_CHECK_ERR(ret, "Failed to open:" // trim(filename))

    ! Since file is just created no need to enter redef
    ret = PIO_def_dim(pio_file, 'timesteps', pio_unlimited, pio_dim)
    PIO_TF_CHECK_ERR(ret, "Failed to define dim:" // trim(filename))

    ret = PIO_def_var(pio_file, PIO_VAR_NAME, PIO_TF_DATA_TYPE, (/pio_dim/), pio_var)
    PIO_TF_CHECK_ERR(ret, "Failed to define var:" // trim(filename))

    ret = PIO_enddef(pio_file)
    PIO_TF_CHECK_ERR(ret, "Failed to enddef:" // trim(filename))

    ! Put scalar vals, one timestep at a time
    do tstep=1,MAX_TIMES
      start(1) = tstep
      count(1) = 1
      exp_val(tstep) = tstep - 1
      pval = tstep - 1
      ret = PIO_put_var(pio_file, pio_var, start, count, pval)
      PIO_TF_CHECK_ERR(ret, "Failed to put scalar var over time:" // trim(filename))
    end do

#ifdef PIO_TEST_CLOSE_OPEN_FOR_SYNC
    call PIO_closefile(pio_file)

    ret = PIO_openfile(pio_tf_iosystem_, pio_file, iotypes(i), filename, PIO_nowrite)
    PIO_TF_CHECK_ERR(ret, "Failed to reopen:" // trim(filename))

    ret = PIO_inq_varid(pio_file, PIO_VAR_NAME, pio_var)
    PIO_TF_CHECK_ERR(ret, "Failed to inq scalar var over time" // trim(filename))
#else
    call PIO_syncfile(pio_file)
#endif

    ret = PIO_get_var(pio_file, pio_var, gval)
    PIO_TF_CHECK_ERR(ret, "Failed to get scalar var over time:" // trim(filename))

    PIO_TF_CHECK_VAL((gval, exp_val), "Got wrong value (scalar var over time)")

    call PIO_closefile(pio_file)
    call PIO_deletefile(pio_tf_iosystem_, filename);
  end do

  if(allocated(iotypes)) then
    deallocate(iotypes)
    deallocate(iotype_descs)
  end if

PIO_TF_AUTO_TEST_SUB_END test_put_get_time_scalar_rec

PIO_TF_AUTO_TEST_SUB_BEGIN test_put_get_1d_str_arr
  Implicit none
  type(file_desc_t) :: pio_file
  character(len=PIO_TF_MAX_STR_LEN) :: filename
  type(var_desc_t)  :: pio_str_arr_var1, pio_str_arr_var2
  integer, dimension(2) :: pio_dims
  integer, parameter :: STR_LEN = 64
  integer, parameter :: NUM_STRS = 32
  character(len=STR_LEN) :: exp_str
  character(len=STR_LEN), dimension(NUM_STRS) :: pstr_arr, gstr_arr
  integer, dimension(2) :: start
  integer, dimension(2) :: count
  integer, parameter :: StrKIND = 512
  character(len=StrKIND), dimension(1) :: single_str_arr
  integer, dimension(:), allocatable :: iotypes
  character(len=PIO_TF_MAX_STR_LEN), dimension(:), allocatable :: iotype_descs
  integer :: num_iotypes
  integer :: i, index, ret

  do index=1,NUM_STRS
    write(exp_str, '(a, i2)') 'DUMMY_STRING, index = ', index
    pstr_arr(index) = exp_str
    gstr_arr(index) = ' '
  end do

  num_iotypes = 0
  call PIO_TF_Get_nc_iotypes(iotypes, iotype_descs, num_iotypes)
  filename = "test_pio_ncdf_get_put.testfile"
  do i=1,num_iotypes
    PIO_TF_LOG(0,*) "Testing type :", iotype_descs(i)
    ret = PIO_createfile(pio_tf_iosystem_, pio_file, iotypes(i), filename, PIO_CLOBBER)
    PIO_TF_CHECK_ERR(ret, "Failed to open:" // trim(filename))

    ! Since file is just created no need to enter redef
    ret = PIO_def_dim(pio_file, 'StrLen', STR_LEN, pio_dims(1))
    PIO_TF_CHECK_ERR(ret, "Failed to define dim:" // trim(filename))

    ret = PIO_def_dim(pio_file, 'nstrs', NUM_STRS, pio_dims(2))
    PIO_TF_CHECK_ERR(ret, "Failed to define dim:" // trim(filename))

    ret = PIO_def_var(pio_file, 'var1_1d_str_arr', PIO_char, (/pio_dims/), pio_str_arr_var1)
    PIO_TF_CHECK_ERR(ret, "Failed to define string array var:" // trim(filename))

    ret = PIO_def_var(pio_file, 'var2_1d_str_arr', PIO_char, (/pio_dims/), pio_str_arr_var2)
    PIO_TF_CHECK_ERR(ret, "Failed to define string array var:" // trim(filename))

    ret = PIO_enddef(pio_file)
    PIO_TF_CHECK_ERR(ret, "Failed to enddef:" // trim(filename))

    ! This calls put_var_1d_text()
    ret = PIO_put_var(pio_file, pio_str_arr_var1, pstr_arr);
    PIO_TF_CHECK_ERR(ret, "Failed to put string array var:" // trim(filename))

    start(1) = 1
    start(2) = 1
    count(1) = STR_LEN
    count(2) = NUM_STRS

    ! This calls put_vara_1d_text()
    ret = PIO_put_var(pio_file, pio_str_arr_var2, start, count, pstr_arr);
    PIO_TF_CHECK_ERR(ret, "Failed to put string array var:" // trim(filename))

#ifdef PIO_TEST_CLOSE_OPEN_FOR_SYNC
    call PIO_closefile(pio_file)

    ret = PIO_openfile(pio_tf_iosystem_, pio_file, iotypes(i), filename, PIO_nowrite)
    PIO_TF_CHECK_ERR(ret, "Failed to reopen:" // trim(filename))

    ret = PIO_inq_varid(pio_file, 'var1_1d_str_arr', pio_str_arr_var1)
    PIO_TF_CHECK_ERR(ret, "Failed to inq string array var:" // trim(filename))

    ret = PIO_inq_varid(pio_file, 'var2_1d_str_arr', pio_str_arr_var2)
    PIO_TF_CHECK_ERR(ret, "Failed to inq string array var:" // trim(filename))
#else
    call PIO_syncfile(pio_file)
#endif

    ! This calls get_var_1d_text()
    ret = PIO_get_var(pio_file, pio_str_arr_var1, gstr_arr);
    PIO_TF_CHECK_ERR(ret, "Failed to get string array var:" // trim(filename))

    do index=1,NUM_STRS
      PIO_TF_CHECK_VAL((gstr_arr(index), pstr_arr(index)), "Got wrong value")
    end do

    do index=1,NUM_STRS
      gstr_arr(index) = ' '
    end do

    ! This calls get_vara_1d_text()
    ret = PIO_get_var(pio_file, pio_str_arr_var2, start, count, gstr_arr);
    PIO_TF_CHECK_ERR(ret, "Failed to get string array var:" // trim(filename))

    do index=1,NUM_STRS
      PIO_TF_CHECK_VAL((gstr_arr(index), pstr_arr(index)), "Got wrong value")
    end do

    count(2) = 1

    ! Read one string at a time, since the sizes differ (i.e. StrLen != StrKIND)
    do index=1,NUM_STRS
      write(exp_str, '(a, i2)') 'DUMMY_STRING, index = ', index

      start(2) = index

      single_str_arr(1) = ' '

      ! This calls get_vara_1d_text()
      ret = PIO_get_var(pio_file, pio_str_arr_var1, start, count, single_str_arr)
      PIO_TF_CHECK_ERR(ret, "Failed to get string array var:" // trim(filename))

      PIO_TF_CHECK_VAL((single_str_arr(1)(1:STR_LEN), exp_str), "Got wrong value")

      single_str_arr(1) = ' '

      ! This calls get_vara_1d_text()
      ret = PIO_get_var(pio_file, pio_str_arr_var2, start, count, single_str_arr)
      PIO_TF_CHECK_ERR(ret, "Failed to get string array var:" // trim(filename))

      PIO_TF_CHECK_VAL((single_str_arr(1)(1:STR_LEN), exp_str), "Got wrong value")
    end do

    call PIO_closefile(pio_file)
    call PIO_deletefile(pio_tf_iosystem_, filename);
  end do
  if(allocated(iotypes)) then
    deallocate(iotypes)
    deallocate(iotype_descs)
  end if

PIO_TF_AUTO_TEST_SUB_END test_put_get_1d_str_arr

PIO_TF_AUTO_TEST_SUB_BEGIN test_put_get_2d_str_arr
  Implicit none
  type(file_desc_t) :: pio_file
  character(len=PIO_TF_MAX_STR_LEN) :: filename
  type(var_desc_t)  :: pio_str_arr_var1, pio_str_arr_var2
  integer, dimension(3) :: pio_dims
  integer, parameter :: STR_LEN = 64
  integer, parameter :: NUM_ROWS = 4
  integer, parameter :: NUM_COLS = 8
  character(len=STR_LEN) :: exp_str
  character(len=STR_LEN), dimension(NUM_ROWS, NUM_COLS) :: pstr_arr, gstr_arr
  integer, dimension(3) :: start
  integer, dimension(3) :: count
  integer, parameter :: StrKIND = 512
  character(len=StrKIND), dimension(1) :: single_str_arr
  integer, dimension(:), allocatable :: iotypes
  character(len=PIO_TF_MAX_STR_LEN), dimension(:), allocatable :: iotype_descs
  integer :: num_iotypes
  integer :: i, row, col, index, ret

  do col=1,NUM_COLS
    do row=1,NUM_ROWS
      ! Array storage in Fortran is column-major
      index = (col - 1) * NUM_ROWS + row
      write(exp_str, '(a, i2)') 'DUMMY_STRING, index = ', index
      pstr_arr(row, col) = exp_str
      gstr_arr(row, col) = ' '
    end do
  end do

  num_iotypes = 0
  call PIO_TF_Get_nc_iotypes(iotypes, iotype_descs, num_iotypes)
  filename = "test_pio_ncdf_get_put.testfile"
  do i=1,num_iotypes
    PIO_TF_LOG(0,*) "Testing type :", iotype_descs(i)
    ret = PIO_createfile(pio_tf_iosystem_, pio_file, iotypes(i), filename, PIO_CLOBBER)
    PIO_TF_CHECK_ERR(ret, "Failed to open:" // trim(filename))

    ! Since file is just created no need to enter redef
    ret = PIO_def_dim(pio_file, 'StrLen', STR_LEN, pio_dims(1))
    PIO_TF_CHECK_ERR(ret, "Failed to define dim:" // trim(filename))

    ret = PIO_def_dim(pio_file, 'col', NUM_COLS, pio_dims(2))
    PIO_TF_CHECK_ERR(ret, "Failed to define dim:" // trim(filename))

    ret = PIO_def_dim(pio_file, 'row', NUM_ROWS, pio_dims(3))
    PIO_TF_CHECK_ERR(ret, "Failed to define dim:" // trim(filename))

    ret = PIO_def_var(pio_file, 'var1_2d_str_arr', PIO_char, (/pio_dims/), pio_str_arr_var1)
    PIO_TF_CHECK_ERR(ret, "Failed to define string array var:" // trim(filename))

    ret = PIO_def_var(pio_file, 'var2_2d_str_arr', PIO_char, (/pio_dims/), pio_str_arr_var2)
    PIO_TF_CHECK_ERR(ret, "Failed to define string array var:" // trim(filename))

    ret = PIO_enddef(pio_file)
    PIO_TF_CHECK_ERR(ret, "Failed to enddef:" // trim(filename))

    ! This calls put_var_2d_text()
    ret = PIO_put_var(pio_file, pio_str_arr_var1, pstr_arr);
    PIO_TF_CHECK_ERR(ret, "Failed to put string array var:" // trim(filename))

    start(1) = 1
    start(2) = 1
    start(3) = 1
    count(1) = STR_LEN
    count(2) = NUM_COLS
    count(3) = NUM_ROWS

    ! This calls put_vara_2d_text()
    ret = PIO_put_var(pio_file, pio_str_arr_var2, start, count, pstr_arr);
    PIO_TF_CHECK_ERR(ret, "Failed to put string array var:" // trim(filename))

#ifdef PIO_TEST_CLOSE_OPEN_FOR_SYNC
    call PIO_closefile(pio_file)

    ret = PIO_openfile(pio_tf_iosystem_, pio_file, iotypes(i), filename, PIO_nowrite)
    PIO_TF_CHECK_ERR(ret, "Failed to reopen:" // trim(filename))

    ret = PIO_inq_varid(pio_file, 'var1_2d_str_arr', pio_str_arr_var1)
    PIO_TF_CHECK_ERR(ret, "Failed to inq string array var:" // trim(filename))

    ret = PIO_inq_varid(pio_file, 'var2_2d_str_arr', pio_str_arr_var2)
    PIO_TF_CHECK_ERR(ret, "Failed to inq string array var:" // trim(filename))
#else
    call PIO_syncfile(pio_file)
#endif

    ! This calls get_var_2d_text()
    ret = PIO_get_var(pio_file, pio_str_arr_var1, gstr_arr);
    PIO_TF_CHECK_ERR(ret, "Failed to get string array var:" // trim(filename))

    do col=1,NUM_COLS
      do row=1,NUM_ROWS
        PIO_TF_CHECK_VAL((gstr_arr(row, col), pstr_arr(row, col)), "Got wrong value")
      end do
    end do

    do col=1,NUM_COLS
      do row=1,NUM_ROWS
        gstr_arr(row, col) = ' '
      end do
    end do

    ! This calls get_vara_2d_text()
    ret = PIO_get_var(pio_file, pio_str_arr_var2, start, count, gstr_arr);
    PIO_TF_CHECK_ERR(ret, "Failed to get string array var:" // trim(filename))

    do col=1,NUM_COLS
      do row=1,NUM_ROWS
        PIO_TF_CHECK_VAL((gstr_arr(row, col), pstr_arr(row, col)), "Got wrong value")
      end do
    end do

    count(2) = 1
    count(3) = 1

    ! Read one string at a time, since the sizes differ (i.e. StrLen != StrKIND)
    do row=1,NUM_ROWS
      do col=1,NUM_COLS
        ! NetCDF uses C row-major convention
        index = (row - 1) * NUM_COLS + col
        write(exp_str, '(a, i2)') 'DUMMY_STRING, index = ', index

        start(2) = col
        start(3) = row

        single_str_arr(1) = ' '

        ! This calls get_vara_1d_text()
        ret = PIO_get_var(pio_file, pio_str_arr_var1, start, count, single_str_arr)
        PIO_TF_CHECK_ERR(ret, "Failed to get string array var:" // trim(filename))

        PIO_TF_CHECK_VAL((single_str_arr(1)(1:STR_LEN), exp_str), "Got wrong value")

        single_str_arr(1) = ' '

        ! This calls get_vara_1d_text()
        ret = PIO_get_var(pio_file, pio_str_arr_var2, start, count, single_str_arr)
        PIO_TF_CHECK_ERR(ret, "Failed to get string array var:" // trim(filename))

        PIO_TF_CHECK_VAL((single_str_arr(1)(1:STR_LEN), exp_str), "Got wrong value")
      end do
    end do

    call PIO_closefile(pio_file)
    call PIO_deletefile(pio_tf_iosystem_, filename);
  end do
  if(allocated(iotypes)) then
    deallocate(iotypes)
    deallocate(iotype_descs)
  end if

PIO_TF_AUTO_TEST_SUB_END test_put_get_2d_str_arr

! Miscellaneous tests for pio_put/get_var for text variables
! 1) Test put/get var for [0:3]d text variables
! 2) Test puts with strings (and hence user buffers) smaller than the variable
! 3) Test gets with strings (and hence user buffers) larger than the variable
PIO_TF_AUTO_TEST_SUB_BEGIN test_put_get_misc_str
  Implicit none
  type(file_desc_t) :: pio_file
  character(len=*), parameter :: filename = "test_pio_ncdf_get_put_misc_str.testfile"
  type(var_desc_t)  :: var0d, var1d, var2d, var3d
  character(len=*), parameter :: var0d_name = "var0d"
  character(len=*), parameter :: var1d_name = "var1d"
  character(len=*), parameter :: var2d_name = "var2d"
  character(len=*), parameter :: var3d_name = "var3d"

  integer, parameter :: SHORT_STR_LEN = 32
  integer, parameter :: LONG_STR_LEN = 128
  integer, parameter :: STR_LEN = 64

  integer, parameter :: NDIMS = 4
  integer, dimension(NDIMS) :: pio_dims
  integer, parameter :: NUM_ROWS = 4
  integer, parameter :: NUM_COLS = 8
  integer, parameter :: NUM_STEPS = 2
  character(len=*), parameter :: dim0_name = "slen"
  character(len=*), parameter :: dim1_name = "row"
  character(len=*), parameter :: dim2_name = "col"
  character(len=*), parameter :: dim3_name = "step"

  character(len=STR_LEN) :: exp_str0d, exp_str1d(NUM_ROWS)
  character(len=STR_LEN) :: exp_str2d(NUM_ROWS, NUM_COLS)
  character(len=STR_LEN) :: exp_str3d(NUM_ROWS, NUM_COLS, NUM_STEPS)
  character(len=STR_LEN) :: gstr0d, gstr1d(NUM_ROWS)
  character(len=STR_LEN) :: gstr2d(NUM_ROWS, NUM_COLS)
  character(len=STR_LEN) :: gstr3d(NUM_ROWS, NUM_COLS, NUM_STEPS)

  character(len=SHORT_STR_LEN) :: exp_sstr0d, exp_sstr1d(NUM_ROWS)
  character(len=SHORT_STR_LEN) :: exp_sstr2d(NUM_ROWS, NUM_COLS)
  character(len=LONG_STR_LEN) :: glstr0d, glstr1d(NUM_ROWS)
  character(len=LONG_STR_LEN) :: glstr2d(NUM_ROWS, NUM_COLS)

  integer, dimension(NDIMS) :: strt, cnt

  integer, dimension(:), allocatable :: iotypes
  character(len=PIO_TF_MAX_STR_LEN), dimension(:), allocatable :: iotype_descs
  integer :: num_iotypes

  ! Formats for the data written out in the text variable
  ! Each string in the variable is of the form
  ! "Index is: VAR_NAME(VAR_IDX,...)"
  ! e.g. For 2D var, var2d, var2d(j,i) = "Index is: var2d(j,i)"
  character(len=*), parameter :: VNAME_WITH_1D_IDX_FMT1 = '("Index is: ",A5,"(",I5,")")'
  character(len=*), parameter :: VNAME_WITH_2D_IDX_FMT1 = '("Index is: ",A5,"(",I5,",",I5,")")'
  character(len=*), parameter :: VNAME_WITH_3D_IDX_FMT1 = '("Index is: ",A5,"(",I5,",",I5,",",I5,")")'
  character(len=*), parameter :: VNAME_WITH_1D_IDX_FMT2 = '("Index is: ",A5,"[",I5,"]")'
  character(len=*), parameter :: VNAME_WITH_2D_IDX_FMT2 = '("Index is: ",A5,"[",I5,",",I5,"]")'
  character(len=*), parameter :: VNAME_WITH_3D_IDX_FMT2 = '("Index is: ",A5,"[",I5,",",I5,",",I5,"]")'

  integer :: i, row, col, step, ret

  num_iotypes = 0
  call PIO_TF_Get_nc_iotypes(iotypes, iotype_descs, num_iotypes)
  do i=1,num_iotypes
    ! Initialize the buffers written out to the variable
    exp_str0d = var0d_name
    exp_sstr0d = var0d_name
    do row=1,NUM_ROWS
      write(exp_str1d(row), VNAME_WITH_1D_IDX_FMT1) var1d_name, row
      write(exp_sstr1d(row), VNAME_WITH_1D_IDX_FMT1) var1d_name, row
      do col=1,NUM_COLS
        write(exp_str2d(row,col), VNAME_WITH_2D_IDX_FMT1) var2d_name, row, col
        write(exp_sstr2d(row,col), VNAME_WITH_2D_IDX_FMT1) var2d_name, row, col
        do step=1,NUM_STEPS
          write(exp_str3d(row,col,step), VNAME_WITH_3D_IDX_FMT1) var2d_name, row, col, step
        end do
      end do
    end do

    PIO_TF_LOG(0,*) "Testing type :", iotype_descs(i)
    ret = PIO_createfile(pio_tf_iosystem_, pio_file, iotypes(i), filename, PIO_CLOBBER)
    PIO_TF_CHECK_ERR(ret, "Failed to open:" // trim(filename))

    ret = PIO_def_dim(pio_file, dim0_name, STR_LEN, pio_dims(1))
    PIO_TF_CHECK_ERR(ret, "Failed to define dim 0:" // trim(filename))

    ret = PIO_def_dim(pio_file, dim1_name, NUM_ROWS, pio_dims(2))
    PIO_TF_CHECK_ERR(ret, "Failed to define dim 1:" // trim(filename))

    ret = PIO_def_dim(pio_file, dim2_name, NUM_COLS, pio_dims(3))
    PIO_TF_CHECK_ERR(ret, "Failed to define dim 2:" // trim(filename))

    ret = PIO_def_dim(pio_file, dim3_name, NUM_STEPS, pio_dims(4))
    PIO_TF_CHECK_ERR(ret, "Failed to define dim 3:" // trim(filename))

    ret = PIO_def_var(pio_file, var0d_name, PIO_char, (/pio_dims(1)/), var0d)
    PIO_TF_CHECK_ERR(ret, "Failed to define 0 dim char array or string in file " // trim(filename))

    ret = PIO_def_var(pio_file, var1d_name, PIO_char, (/pio_dims(1), pio_dims(2)/), var1d)
    PIO_TF_CHECK_ERR(ret, "Failed to define 1 dim char array or 1d array of strings in file " // trim(filename))

    ret = PIO_def_var(pio_file, var2d_name, PIO_char, (/pio_dims(1), pio_dims(2), pio_dims(3)/), var2d)
    PIO_TF_CHECK_ERR(ret, "Failed to define 2 dim char array or 2d array of strings in file " // trim(filename))

    ret = PIO_def_var(pio_file, var3d_name, PIO_char, pio_dims, var3d)
    PIO_TF_CHECK_ERR(ret, "Failed to define 3 dim char array or 3d array of strings in file " // trim(filename))

    ret = PIO_enddef(pio_file)
    PIO_TF_CHECK_ERR(ret, "Failed to enddef:" // trim(filename))

    ! This calls put_var_0d_text()
    ret = PIO_put_var(pio_file, var0d, exp_str0d);
    PIO_TF_CHECK_ERR(ret, "Failed to put 0 dim char array or string in file " // trim(filename))

    ! This calls put_var_1d_text()
    ret = PIO_put_var(pio_file, var1d, exp_str1d);
    PIO_TF_CHECK_ERR(ret, "Failed to put 1d array of strings in file " // trim(filename))

    ! This calls put_var_2d_text()
    ret = PIO_put_var(pio_file, var2d, exp_str2d);
    PIO_TF_CHECK_ERR(ret, "Failed to put 2d array of strings in file " // trim(filename))

    ! This calls put_var_3d_text()
    ret = PIO_put_var(pio_file, var3d, exp_str3d);
    PIO_TF_CHECK_ERR(ret, "Failed to put 3d array of strings in file " // trim(filename))

    ! Sync data to disk
#ifdef PIO_TEST_CLOSE_OPEN_FOR_SYNC
    call PIO_closefile(pio_file)

    ret = PIO_openfile(pio_tf_iosystem_, pio_file, iotypes(i), filename, PIO_write)
    PIO_TF_CHECK_ERR(ret, "Failed to reopen:" // trim(filename))

    ret = PIO_inq_varid(pio_file, var0d_name, var0d)
    PIO_TF_CHECK_ERR(ret, "Failed to inquire 0d char or string var in file " // trim(filename))

    ret = PIO_inq_varid(pio_file, var1d_name, var1d)
    PIO_TF_CHECK_ERR(ret, "Failed to inquire 1d array of strings var in file " // trim(filename))

    ret = PIO_inq_varid(pio_file, var2d_name, var2d)
    PIO_TF_CHECK_ERR(ret, "Failed to inquire 2d array of strings var in file " // trim(filename))

    ret = PIO_inq_varid(pio_file, var3d_name, var3d)
    PIO_TF_CHECK_ERR(ret, "Failed to inquire 3d array of strings var in file " // trim(filename))
#else
    call PIO_syncfile(pio_file)
#endif

    ! This calls get_var_0d_text()
    ret = PIO_get_var(pio_file, var0d, gstr0d);
    PIO_TF_CHECK_ERR(ret, "Failed to get 0d char var in file " // trim(filename))

    PIO_TF_CHECK_VAL((gstr0d, exp_str0d), "Got wrong value for 0d char var")

    ! This calls get_var_1d_text()
    ret = PIO_get_var(pio_file, var1d, gstr1d);
    PIO_TF_CHECK_ERR(ret, "Failed to get 1d char var in file " // trim(filename))

    PIO_TF_CHECK_VAL((gstr1d, exp_str1d), "Got wrong value for 1d char var")

    ! This calls get_var_2d_text()
    ret = PIO_get_var(pio_file, var2d, gstr2d);
    PIO_TF_CHECK_ERR(ret, "Failed to get 2d char var in file " // trim(filename))

    PIO_TF_CHECK_VAL((gstr2d, exp_str2d), "Got wrong value for 2d char var")

    ! This calls get_var_3d_text()
    ret = PIO_get_var(pio_file, var3d, gstr3d);
    PIO_TF_CHECK_ERR(ret, "Failed to get 3d char var in file " // trim(filename))

    PIO_TF_CHECK_VAL((gstr3d, exp_str3d), "Got wrong value for 3d char var")

    ! Re-write the variables in the file with a smaller (than the variable size)
    ! buffer
    exp_sstr0d = var0d_name // "_"
    do row=1,NUM_ROWS
      write(exp_sstr1d(row), VNAME_WITH_1D_IDX_FMT2) var1d_name, row
      do col=1,NUM_COLS
        write(exp_sstr2d(row,col), VNAME_WITH_2D_IDX_FMT2) var2d_name, row, col
      end do
    end do

    ! This calls put_var_0d_text()
    ret = PIO_put_var(pio_file, var0d, exp_sstr0d);
    PIO_TF_CHECK_ERR(ret, "Failed to put 0 dim char array or string with small buf in file " // trim(filename))

    ! This calls put_var_1d_text()
    ret = PIO_put_var(pio_file, var1d, exp_sstr1d);
    PIO_TF_CHECK_ERR(ret, "Failed to put 1d array of strings with small buf in file " // trim(filename))

    ! This calls put_var_2d_text()
    ret = PIO_put_var(pio_file, var2d, exp_sstr2d);
    PIO_TF_CHECK_ERR(ret, "Failed to put 2d array of strings with small buf in file " // trim(filename))

    ! Sync data to disk
#ifdef PIO_TEST_CLOSE_OPEN_FOR_SYNC
    call PIO_closefile(pio_file)

    ret = PIO_openfile(pio_tf_iosystem_, pio_file, iotypes(i), filename, PIO_write)
    PIO_TF_CHECK_ERR(ret, "Failed to reopen:" // trim(filename))

    ret = PIO_inq_varid(pio_file, var0d_name, var0d)
    PIO_TF_CHECK_ERR(ret, "Failed to inquire 0d char or string var in file " // trim(filename))

    ret = PIO_inq_varid(pio_file, var1d_name, var1d)
    PIO_TF_CHECK_ERR(ret, "Failed to inquire 1d array of strings var in file " // trim(filename))

    ret = PIO_inq_varid(pio_file, var2d_name, var2d)
    PIO_TF_CHECK_ERR(ret, "Failed to inquire 2d array of strings var in file " // trim(filename))

    ret = PIO_inq_varid(pio_file, var3d_name, var3d)
    PIO_TF_CHECK_ERR(ret, "Failed to inquire 3d array of strings var in file " // trim(filename))

#else
    call PIO_syncfile(pio_file)
#endif

    ! Read data back with a larger (than the size of the variable) buffer
    ! This calls get_var_0d_text()
    ret = PIO_get_var(pio_file, var0d, glstr0d);
    PIO_TF_CHECK_ERR(ret, "Failed to get 0d char var with large buf in file " // trim(filename))

    PIO_TF_CHECK_VAL((glstr0d, exp_sstr0d), "Got wrong value for 0d char var with large buf")

    ! This calls get_var_1d_text()
    ret = PIO_get_var(pio_file, var1d, glstr1d);
    PIO_TF_CHECK_ERR(ret, "Failed to get 1d char var with large buf in file " // trim(filename))

    PIO_TF_CHECK_VAL((glstr1d, exp_sstr1d), "Got wrong value for 1d char var with large buf")

    ! This calls get_var_2d_text()
    ret = PIO_get_var(pio_file, var2d, glstr2d);
    PIO_TF_CHECK_ERR(ret, "Failed to get 2d char var with large buf in file " // trim(filename))

    PIO_TF_CHECK_VAL((glstr2d, exp_sstr2d), "Got wrong value for 2d char var with large buf")

    ! Re-write the variables in the file to test hyperslab puts
    do row=1,NUM_ROWS
      write(exp_str1d(row), VNAME_WITH_1D_IDX_FMT1) var1d_name, row
      write(exp_sstr1d(row), VNAME_WITH_1D_IDX_FMT1) var1d_name, row
      do col=1,NUM_COLS
        write(exp_str2d(row,col), VNAME_WITH_2D_IDX_FMT1) var2d_name, row, col
        write(exp_sstr2d(row,col), VNAME_WITH_2D_IDX_FMT1) var2d_name, row, col
        do step=1,NUM_STEPS
          write(exp_str3d(row,col,step), VNAME_WITH_3D_IDX_FMT1) var3d_name, row, col, step
        end do
      end do
    end do

    strt = 1
    cnt = 0
    cnt(1) = STR_LEN
    cnt(2) = NUM_ROWS

    ! This calls put_vara_1d_text()
    ret = PIO_put_var(pio_file, var1d, strt, cnt, exp_str1d);
    PIO_TF_CHECK_ERR(ret, "Failed to put hslab of 1d array of strings in file " // trim(filename))

    strt = 1
    cnt = 0
    cnt(1) = STR_LEN
    cnt(2) = NUM_ROWS
    cnt(3) = NUM_COLS

    ! This calls put_vara_2d_text()
    ret = PIO_put_var(pio_file, var2d, strt, cnt, exp_str2d);
    PIO_TF_CHECK_ERR(ret, "Failed to put hslab of 2d array of strings in file " // trim(filename))

    strt = 1
    cnt = 0
    cnt(1) = STR_LEN
    cnt(2) = NUM_ROWS
    cnt(3) = NUM_COLS
    cnt(4) = NUM_STEPS

    ! This calls put_vara_3d_text()
    ret = PIO_put_var(pio_file, var3d, strt, cnt, exp_str3d);
    PIO_TF_CHECK_ERR(ret, "Failed to put hslab of 3d array of strings in file " // trim(filename))

    ! Sync data to disk
#ifdef PIO_TEST_CLOSE_OPEN_FOR_SYNC
    call PIO_closefile(pio_file)

    ret = PIO_openfile(pio_tf_iosystem_, pio_file, iotypes(i), filename, PIO_nowrite)
    PIO_TF_CHECK_ERR(ret, "Failed to reopen:" // trim(filename))

    ret = PIO_inq_varid(pio_file, var1d_name, var1d)
    PIO_TF_CHECK_ERR(ret, "Failed to inquire 1d array of strings var in file " // trim(filename))

    ret = PIO_inq_varid(pio_file, var2d_name, var2d)
    PIO_TF_CHECK_ERR(ret, "Failed to inquire 2d array of strings var in file " // trim(filename))

    ret = PIO_inq_varid(pio_file, var3d_name, var3d)
    PIO_TF_CHECK_ERR(ret, "Failed to inquire 3d array of strings var in file " // trim(filename))
#else
    call PIO_syncfile(pio_file)
#endif

    ! This calls get_var_1d_text()
    ret = PIO_get_var(pio_file, var1d, gstr1d);
    PIO_TF_CHECK_ERR(ret, "Failed to get 1d char var in file " // trim(filename))

    PIO_TF_CHECK_VAL((gstr1d, exp_str1d), "Got wrong value for 1d char var written with hslab put")

    ! This calls get_var_2d_text()
    ret = PIO_get_var(pio_file, var2d, gstr2d);
    PIO_TF_CHECK_ERR(ret, "Failed to get 2d char var in file " // trim(filename))

    PIO_TF_CHECK_VAL((gstr2d, exp_str2d), "Got wrong value for 2d char var written with hslab put")

    ! This calls get_var_3d_text()
    ret = PIO_get_var(pio_file, var3d, gstr3d);
    PIO_TF_CHECK_ERR(ret, "Failed to get 3d char var in file " // trim(filename))

    PIO_TF_CHECK_VAL((gstr3d, exp_str3d), "Got wrong value for 3d char var written with hslab put")

    call PIO_closefile(pio_file)
    call PIO_deletefile(pio_tf_iosystem_, filename);
  end do
  if(allocated(iotypes)) then
    deallocate(iotypes)
    deallocate(iotype_descs)
  end if

PIO_TF_AUTO_TEST_SUB_END test_put_get_misc_str

! Test puts of a text variables, one frame at a time
PIO_TF_AUTO_TEST_SUB_BEGIN test_put_get_str_frames
  Implicit none
  type(file_desc_t) :: pio_file
  character(len=*), parameter :: filename = "test_pio_ncdf_get_str_frames.testfile"
  type(var_desc_t)  :: var1d, var2d, var3d
  character(len=*), parameter :: var1d_name = "var1d"
  character(len=*), parameter :: var2d_name = "var2d"
  character(len=*), parameter :: var3d_name = "var3d"

  integer, parameter :: SHORT_STR_LEN = 32
  integer, parameter :: LONG_STR_LEN = 128
  integer, parameter :: STR_LEN = 64

  integer, parameter :: NDIMS = 4
  integer, dimension(NDIMS) :: pio_dims
  integer, parameter :: NUM_ROWS = 4
  integer, parameter :: NUM_COLS = 8
  integer, parameter :: NUM_STEPS = 6
  character(len=*), parameter :: dim0_name = "slen"
  character(len=*), parameter :: dim1_name = "row"
  character(len=*), parameter :: dim2_name = "col"
  character(len=*), parameter :: dim3_name = "step"

  character(len=STR_LEN) :: exp_str1d(NUM_ROWS)
  character(len=STR_LEN) :: exp_str2d(NUM_ROWS, NUM_COLS)
  character(len=STR_LEN) :: exp_str3d(NUM_ROWS, NUM_COLS, NUM_STEPS)
  character(len=STR_LEN) :: frame_str1d(1)
  character(len=STR_LEN) :: frame_str2d(NUM_ROWS, 1)
  character(len=STR_LEN) :: frame_str3d(NUM_ROWS, NUM_COLS, 1)
  character(len=STR_LEN) :: gstr1d(NUM_ROWS)
  character(len=STR_LEN) :: gstr2d(NUM_ROWS, NUM_COLS)
  character(len=STR_LEN) :: gstr3d(NUM_ROWS, NUM_COLS, NUM_STEPS)

  character(len=SHORT_STR_LEN) :: exp_sstr1d(NUM_ROWS)
  character(len=SHORT_STR_LEN) :: exp_sstr2d(NUM_ROWS, NUM_COLS)

  integer, dimension(NDIMS) :: strt, cnt

  integer, dimension(:), allocatable :: iotypes
  character(len=PIO_TF_MAX_STR_LEN), dimension(:), allocatable :: iotype_descs
  integer :: num_iotypes

  ! Formats for the data written out in the text variable
  ! Each string in the variable is of the form
  ! "Index is: VAR_NAME(VAR_IDX,...)"
  ! e.g. For 2D var, var2d, var2d(j,i) = "Index is: var2d(j,i)"
  character(len=*), parameter :: VNAME_WITH_1D_IDX_FMT1 = '("Index is: ",A5,"(",I5,")")'
  character(len=*), parameter :: VNAME_WITH_2D_IDX_FMT1 = '("Index is: ",A5,"(",I5,",",I5,")")'
  character(len=*), parameter :: VNAME_WITH_3D_IDX_FMT1 = '("Index is: ",A5,"(",I5,",",I5,",",I5,")")'
  character(len=*), parameter :: VNAME_WITH_1D_IDX_FMT2 = '("Index is: ",A5,"[",I5,"]")'
  character(len=*), parameter :: VNAME_WITH_2D_IDX_FMT2 = '("Index is: ",A5,"[",I5,",",I5,"]")'
  character(len=*), parameter :: VNAME_WITH_3D_IDX_FMT2 = '("Index is: ",A5,"[",I5,",",I5,",",I5,"]")'

  integer :: i, row, col, step, ret

  num_iotypes = 0
  call PIO_TF_Get_nc_iotypes(iotypes, iotype_descs, num_iotypes)
  ! Init buffers to be written out to the variables
  do i=1,num_iotypes
    do row=1,NUM_ROWS
      write(exp_str1d(row), VNAME_WITH_1D_IDX_FMT1) var2d_name, row
      write(exp_sstr1d(row), VNAME_WITH_1D_IDX_FMT1) var2d_name, row
      do col=1,NUM_COLS
        write(exp_str2d(row,col), VNAME_WITH_2D_IDX_FMT1) var2d_name, row, col
        write(exp_sstr2d(row,col), VNAME_WITH_2D_IDX_FMT1) var2d_name, row, col
        do step=1,NUM_STEPS
          write(exp_str3d(row,col,step), VNAME_WITH_3D_IDX_FMT1) var3d_name, row, col, step
        end do
      end do
    end do

    PIO_TF_LOG(0,*) "Testing type :", iotype_descs(i)
    ret = PIO_createfile(pio_tf_iosystem_, pio_file, iotypes(i), filename, PIO_CLOBBER)
    PIO_TF_CHECK_ERR(ret, "Failed to open:" // trim(filename))

    ret = PIO_def_dim(pio_file, dim0_name, STR_LEN, pio_dims(1))
    PIO_TF_CHECK_ERR(ret, "Failed to define dim 0:" // trim(filename))

    ret = PIO_def_dim(pio_file, dim1_name, NUM_ROWS, pio_dims(2))
    PIO_TF_CHECK_ERR(ret, "Failed to define dim 1:" // trim(filename))

    ret = PIO_def_dim(pio_file, dim2_name, NUM_COLS, pio_dims(3))
    PIO_TF_CHECK_ERR(ret, "Failed to define dim 2:" // trim(filename))

    ret = PIO_def_dim(pio_file, dim3_name, NUM_STEPS, pio_dims(4))
    PIO_TF_CHECK_ERR(ret, "Failed to define dim 3:" // trim(filename))

    ret = PIO_def_var(pio_file, var1d_name, PIO_char, (/pio_dims(1), pio_dims(2)/), var1d)
    PIO_TF_CHECK_ERR(ret, "Failed to define 1 dim char array or 1d array of strings in file " // trim(filename))

    ret = PIO_def_var(pio_file, var2d_name, PIO_char, (/pio_dims(1), pio_dims(2), pio_dims(3)/), var2d)
    PIO_TF_CHECK_ERR(ret, "Failed to define 2 dim char array or 2d array of strings in file " // trim(filename))

    ret = PIO_def_var(pio_file, var3d_name, PIO_char, pio_dims, var3d)
    PIO_TF_CHECK_ERR(ret, "Failed to define 3 dim char array or 3d array of strings in file " // trim(filename))

    ret = PIO_enddef(pio_file)
    PIO_TF_CHECK_ERR(ret, "Failed to enddef:" // trim(filename))

    ! Write the 1d text variable, 1 string at a time
    do row=1,NUM_ROWS
      strt = 1
      cnt = 0
      strt(1) = 1
      strt(2) = row
      cnt(1) = STR_LEN
      cnt(2) = 1

      frame_str1d(1) = exp_str1d(row)
      ! This calls put_vara_1d_text()
      ret = PIO_put_var(pio_file, var1d, strt, cnt, frame_str1d);
      PIO_TF_CHECK_ERR(ret, "Failed to put 1d array of strings 1 frame at a time in file " // trim(filename))
    end do

    ! Write the 2d text variable, 1 array/row of strings at a time
    do col=1,NUM_COLS
      strt = 1
      cnt = 0
      strt(1) = 1
      strt(2) = 1
      strt(3) = col
      cnt(1) = STR_LEN
      cnt(2) = NUM_ROWS
      cnt(3) = 1

      frame_str2d(:,1) = exp_str2d(:,col)
      ! This calls put_vara_2d_text()
      ret = PIO_put_var(pio_file, var2d, strt, cnt, frame_str2d);
      PIO_TF_CHECK_ERR(ret, "Failed to put 2d array of strings 1 frame at a time in file " // trim(filename))
    end do

    ! Write the 3d text variable, 1 2d array (row x col) of strings at a time
    do step=1,NUM_STEPS
      strt = 1
      cnt = 0
      strt(1) = 1
      strt(2) = 1
      strt(3) = 1
      strt(4) = step
      cnt(1) = STR_LEN
      cnt(2) = NUM_ROWS
      cnt(3) = NUM_COLS
      cnt(4) = 1

      frame_str3d(:,:,1) = exp_str3d(:,:,step)
      ! This calls put_vara_3d_text()
      ret = PIO_put_var(pio_file, var3d, strt, cnt, frame_str3d);
      PIO_TF_CHECK_ERR(ret, "Failed to put 3d array of strings 1 frame at a time in file " // trim(filename))
    end do

    ! Sync data to disk
#ifdef PIO_TEST_CLOSE_OPEN_FOR_SYNC
    call PIO_closefile(pio_file)

    ret = PIO_openfile(pio_tf_iosystem_, pio_file, iotypes(i), filename, PIO_nowrite)
    PIO_TF_CHECK_ERR(ret, "Failed to reopen:" // trim(filename))

    ret = PIO_inq_varid(pio_file, var1d_name, var1d)
    PIO_TF_CHECK_ERR(ret, "Failed to inquire 1d array of strings var in file " // trim(filename))

    ret = PIO_inq_varid(pio_file, var2d_name, var2d)
    PIO_TF_CHECK_ERR(ret, "Failed to inquire 2d array of strings var in file " // trim(filename))

    ret = PIO_inq_varid(pio_file, var3d_name, var3d)
    PIO_TF_CHECK_ERR(ret, "Failed to inquire 3d array of strings var in file " // trim(filename))
#else
    call PIO_syncfile(pio_file)
#endif

    ! This calls get_var_1d_text()
    ret = PIO_get_var(pio_file, var1d, gstr1d);
    PIO_TF_CHECK_ERR(ret, "Failed to get 1d char var in file " // trim(filename))

    PIO_TF_CHECK_VAL((gstr1d, exp_str1d), "Got wrong value for 1d char var")

    ! This calls get_var_2d_text()
    ret = PIO_get_var(pio_file, var2d, gstr2d);
    PIO_TF_CHECK_ERR(ret, "Failed to get 2d char var in file " // trim(filename))

    PIO_TF_CHECK_VAL((gstr2d, exp_str2d), "Got wrong value for 2d char var")

    ! This calls get_var_3d_text()
    ret = PIO_get_var(pio_file, var3d, gstr3d);
    PIO_TF_CHECK_ERR(ret, "Failed to get 3d char var in file " // trim(filename))

    PIO_TF_CHECK_VAL((gstr3d, exp_str3d), "Got wrong value for 3d char var")

    call PIO_closefile(pio_file)
    call PIO_deletefile(pio_tf_iosystem_, filename);
  end do
  if(allocated(iotypes)) then
    deallocate(iotypes)
    deallocate(iotype_descs)
  end if

PIO_TF_AUTO_TEST_SUB_END test_put_get_str_frames

! Test puts of text variables, varying the index of the output var written out.
! Although index/starts of the output variable is specified the counts are
! not provided.
PIO_TF_AUTO_TEST_SUB_BEGIN test_put_get_str_idx
  Implicit none
  type(file_desc_t) :: pio_file
  character(len=*), parameter :: filename = "test_pio_ncdf_get_str_idx.testfile"
  type(var_desc_t)  :: var1d, var1d_long, var1d_shrt, var1d_trnc, var1d_midx
  ! Variable names of length 5 chars
  character(len=*), parameter :: var1d_name = "var1d"
  ! Variable names of length 10 chars
  character(len=*), parameter :: var1d_long_name = "var1d_long"
  character(len=*), parameter :: var1d_shrt_name = "var1d_shrt"
  character(len=*), parameter :: var1d_trnc_name = "var1d_trnc"
  character(len=*), parameter :: var1d_midx_name = "var1d_midx"

  character(len=*), parameter :: var1d_tmpl_name = "var1d_____"

  integer, parameter :: SHORT_STR_LEN = 32
  integer, parameter :: STR_LEN = 64
  integer, parameter :: LONG_STR_LEN = 128

  integer, parameter :: NDIMS = 2
  integer, dimension(NDIMS) :: pio_dims
  integer, parameter :: NUM_ROWS = 10

  character(len=*), parameter :: dim0_name = "slen"
  character(len=*), parameter :: dim1_name = "row"

  character(len=STR_LEN) :: exp_str1d(NUM_ROWS)
  character(len=STR_LEN) :: frame_str1d
  character(len=STR_LEN) :: gstr1d(NUM_ROWS)

  character(len=STR_LEN) :: exp_shrt_str1d(NUM_ROWS)
  character(len=SHORT_STR_LEN) :: frame_shrt_str1d

  character(len=STR_LEN) :: exp_long_str1d(NUM_ROWS)
  character(len=LONG_STR_LEN) :: frame_long_str1d

  character(len=LONG_STR_LEN) :: exp_trnc_str1d(NUM_ROWS)
  character(len=LONG_STR_LEN) :: frame_trnc_str1d(NUM_ROWS)

  character(len=STR_LEN) :: exp_midx_str1d(NUM_ROWS)
  character(len=LONG_STR_LEN) :: frame1_midx_str1d(NUM_ROWS)

  integer, dimension(NDIMS) :: strt

  integer, dimension(:), allocatable :: iotypes
  character(len=PIO_TF_MAX_STR_LEN), dimension(:), allocatable :: iotype_descs
  integer :: num_iotypes

  ! Formats for the data written out in the text variable
  ! Each string in the variable is of the form
  ! "Index is: VAR_NAME(VAR_IDX)"
  ! e.g. var1d(i) = "Index is: var1d(i)"
  character(len=*), parameter :: VNAME_WITH_1D_IDX_FMT1 = '("Index is: ",A5,"(",I5,")")'
  character(len=*), parameter :: VNAME_WITH_1D_IDX_FMT2 = '("Index is: ",A10,"(",I5,")")'

  integer, parameter :: VNAME_IDX_IN_VNAME_WITH_1D_IDX_FMT2 = 11

  integer :: strt_idx, end_idx
  integer :: i, j, row, ret

  num_iotypes = 0
  call PIO_TF_Get_nc_iotypes(iotypes, iotype_descs, num_iotypes)
  do i=1,num_iotypes
    ! Init buffers to be written out to the variables
    do row=1,NUM_ROWS
      write(exp_str1d(row), VNAME_WITH_1D_IDX_FMT1) var1d_name, row
      write(exp_shrt_str1d(row), VNAME_WITH_1D_IDX_FMT2) var1d_shrt_name, row
      write(exp_long_str1d(row), VNAME_WITH_1D_IDX_FMT2) var1d_long_name, row
      write(exp_trnc_str1d(row), VNAME_WITH_1D_IDX_FMT2) var1d_trnc_name, row
      write(frame_trnc_str1d(row), VNAME_WITH_1D_IDX_FMT2) var1d_trnc_name, row
      ! The expected string, exp_trnc_str1d(row), is the same length as the
      ! variable, STR_LEN
      ! exp_trnc_str1d(i) = "Index is: var1d_trnc(i)8901234567890..."
      ! The frames written out, frame_trnc_str1d(row), is larger and contains
      ! non-space characters that will be truncated while written out
      ! frame_trnc_str1d(i) = "Index is: var1d_trnc(i)8901234567890..."
      strt_idx = len_trim(exp_trnc_str1d(row)) + 1
      end_idx = min(STR_LEN,len(exp_trnc_str1d(row)))
      do j=strt_idx,end_idx
        write(exp_trnc_str1d(row)(j:j), '(I1)') mod(j,10)
      end do
      strt_idx = len_trim(frame_trnc_str1d(row)) + 1
      end_idx = len(frame_trnc_str1d(row))
      do j=strt_idx,end_idx
        write(frame_trnc_str1d(row)(j:j), '(I1)') mod(j,10)
      end do

      write(exp_midx_str1d(row), VNAME_WITH_1D_IDX_FMT2) var1d_midx_name, row
      write(frame1_midx_str1d(row), VNAME_WITH_1D_IDX_FMT2) var1d_tmpl_name, row
    end do

    PIO_TF_LOG(0,*) "Testing type :", iotype_descs(i)
    ret = PIO_createfile(pio_tf_iosystem_, pio_file, iotypes(i), filename, PIO_CLOBBER)
    PIO_TF_CHECK_ERR(ret, "Failed to open:" // trim(filename))

    ret = PIO_def_dim(pio_file, dim0_name, STR_LEN, pio_dims(1))
    PIO_TF_CHECK_ERR(ret, "Failed to define dim 0:" // trim(filename))

    ret = PIO_def_dim(pio_file, dim1_name, NUM_ROWS, pio_dims(2))
    PIO_TF_CHECK_ERR(ret, "Failed to define dim 1:" // trim(filename))

    ret = PIO_def_var(pio_file, var1d_name, PIO_char, (/pio_dims(1), pio_dims(2)/), var1d)
    PIO_TF_CHECK_ERR(ret, "Failed to define 1 dim char array or 1d array of strings in file " // trim(filename))

    ret = PIO_def_var(pio_file, var1d_shrt_name, PIO_char, (/pio_dims(1), pio_dims(2)/), var1d_shrt)
    PIO_TF_CHECK_ERR(ret, "Failed to define 1 dim char array or 1d array of short strings in file " // trim(filename))

    ret = PIO_def_var(pio_file, var1d_long_name, PIO_char, (/pio_dims(1), pio_dims(2)/), var1d_long)
    PIO_TF_CHECK_ERR(ret, "Failed to define 1 dim char array or 1d array of long strings in file " // trim(filename))

    ret = PIO_def_var(pio_file, var1d_trnc_name, PIO_char, (/pio_dims(1), pio_dims(2)/), var1d_trnc)
    PIO_TF_CHECK_ERR(ret, "Failed to define 1 dim char array or 1d array of truncatable strings in file " // trim(filename))

    ret = PIO_def_var(pio_file, var1d_midx_name, PIO_char, (/pio_dims(1), pio_dims(2)/), var1d_midx)
    PIO_TF_CHECK_ERR(ret, "Failed to define 1 dim char array or 1d array of truncatable strings in file " // trim(filename))

    ret = PIO_enddef(pio_file)
    PIO_TF_CHECK_ERR(ret, "Failed to enddef:" // trim(filename))

    ! Write the 1d text variable, 1 string at a time
    do row=1,NUM_ROWS
      strt = 1
      strt(1) = 1
      strt(2) = row

      frame_str1d = exp_str1d(row)
      ! This calls put_vara_1d_text()
      ret = PIO_put_var(pio_file, var1d, strt, frame_str1d);
      PIO_TF_CHECK_ERR(ret, "Failed to put 1d array of strings 1 string at a time to file " // trim(filename))
    end do

    ! Write the 1d text variable, 1 string at a time
    ! The string written out is shorter than the size of the 1 dim, string length, of the variable
    do row=1,NUM_ROWS
      strt = 1
      strt(1) = 1
      strt(2) = row

      frame_shrt_str1d = exp_shrt_str1d(row)(1:len(frame_shrt_str1d))
      ! This calls put_vara_1d_text()
      ret = PIO_put_var(pio_file, var1d_shrt, strt, frame_shrt_str1d);
      PIO_TF_CHECK_ERR(ret, "Failed to put 1d array of short strings 1 string at a time to file " // trim(filename))
    end do

    ! Write the 1d text variable, 1 string at a time
    ! The string written out is longer than the size of the 1 dim, string length, of the variable
    do row=1,NUM_ROWS
      strt = 1
      strt(1) = 1
      strt(2) = row

      frame_long_str1d = exp_long_str1d(row)
      ! This calls put_vara_1d_text()
      ret = PIO_put_var(pio_file, var1d_long, strt, frame_long_str1d);
      PIO_TF_CHECK_ERR(ret, "Failed to put 1d array of long strings 1 string at a time to file " // trim(filename))
    end do

    ! Write the 1d text variable, 1 string at a time
    ! The string written out is longer than the size of the 1 dim, string length, of the variable
    ! (and the contents of the string will be truncated)
    do row=1,NUM_ROWS
      strt = 1
      strt(1) = 1
      strt(2) = row

      ! This calls put_vara_1d_text()
      ret = PIO_put_var(pio_file, var1d_trnc, strt, frame_trnc_str1d(row));
      PIO_TF_CHECK_ERR(ret, "Failed to put 1d array of truncatable strings 1 string at a time to file " // trim(filename))
    end do

    ! Write the 1d text variable, 1 string at a time
    ! The string written out is longer than the size of the 1 dim, string length, of the variable
    ! However the trim length of the string is <= the size of the 1st dim
    ! The string is modified again by writing out contents at an index
    do row=1,NUM_ROWS
      ! Write out the string with variable template name
      ! vname_midx(i) = "Index is: vname_____(i)"
      strt = 1
      strt(1) = 1
      strt(2) = row

      ! This calls put_vara_1d_text()
      ret = PIO_put_var(pio_file, var1d_midx, strt, frame1_midx_str1d(row));
      PIO_TF_CHECK_ERR(ret, "Failed to put 1d array of long strings 1 string at a time to file " // trim(filename))
    end do

    ! Sync data to disk
#ifdef PIO_TEST_CLOSE_OPEN_FOR_SYNC
    call PIO_closefile(pio_file)

    ret = PIO_openfile(pio_tf_iosystem_, pio_file, iotypes(i), filename, PIO_write)
    PIO_TF_CHECK_ERR(ret, "Failed to reopen:" // trim(filename))

    ret = PIO_inq_varid(pio_file, var1d_name, var1d)
    PIO_TF_CHECK_ERR(ret, "Failed to inquire 1d array of strings var in file " // trim(filename))

    ret = PIO_inq_varid(pio_file, var1d_shrt_name, var1d_shrt)
    PIO_TF_CHECK_ERR(ret, "Failed to inquire 1d array of strings var in file " // trim(filename))

    ret = PIO_inq_varid(pio_file, var1d_long_name, var1d_long)
    PIO_TF_CHECK_ERR(ret, "Failed to inquire 1d array of strings var in file " // trim(filename))

    ret = PIO_inq_varid(pio_file, var1d_trnc_name, var1d_trnc)
    PIO_TF_CHECK_ERR(ret, "Failed to inquire 1d array of strings var in file " // trim(filename))

    ret = PIO_inq_varid(pio_file, var1d_midx_name, var1d_midx)
    PIO_TF_CHECK_ERR(ret, "Failed to inquire 1d array of strings var in file " // trim(filename))
#else
    call PIO_syncfile(pio_file)
#endif

    do row=1,NUM_ROWS
      ! Change the variable name to "vname_mdix" by writing at the index for the variable name
      ! vname_midx(i) = "Index is: vname_midx(i)"
      strt = 1
      strt(1) = VNAME_IDX_IN_VNAME_WITH_1D_IDX_FMT2
      strt(2) = row

      ! This calls put_vara_1d_text()
      ret = PIO_put_var(pio_file, var1d_midx, strt, var1d_midx_name);
      PIO_TF_CHECK_ERR(ret, "Failed to put 1d array of long strings 1 string at a time to file " // trim(filename))
    end do

    ! Sync data to disk
#ifdef PIO_TEST_CLOSE_OPEN_FOR_SYNC
    call PIO_closefile(pio_file)

    ret = PIO_openfile(pio_tf_iosystem_, pio_file, iotypes(i), filename, PIO_nowrite)
    PIO_TF_CHECK_ERR(ret, "Failed to reopen:" // trim(filename))

    ret = PIO_inq_varid(pio_file, var1d_name, var1d)
    PIO_TF_CHECK_ERR(ret, "Failed to inquire 1d array of strings var in file " // trim(filename))

    ret = PIO_inq_varid(pio_file, var1d_shrt_name, var1d_shrt)
    PIO_TF_CHECK_ERR(ret, "Failed to inquire 1d array of strings var in file " // trim(filename))

    ret = PIO_inq_varid(pio_file, var1d_long_name, var1d_long)
    PIO_TF_CHECK_ERR(ret, "Failed to inquire 1d array of strings var in file " // trim(filename))

    ret = PIO_inq_varid(pio_file, var1d_trnc_name, var1d_trnc)
    PIO_TF_CHECK_ERR(ret, "Failed to inquire 1d array of strings var in file " // trim(filename))

    ret = PIO_inq_varid(pio_file, var1d_midx_name, var1d_midx)
    PIO_TF_CHECK_ERR(ret, "Failed to inquire 1d array of strings var in file " // trim(filename))
#else
    call PIO_syncfile(pio_file)
#endif

    ! This calls get_var_1d_text()
    ret = PIO_get_var(pio_file, var1d, gstr1d);
    PIO_TF_CHECK_ERR(ret, "Failed to get 1d char var in file " // trim(filename))

    PIO_TF_CHECK_VAL((gstr1d, exp_str1d), "Got wrong value for 1d char var")

    gstr1d = ''
    ret = PIO_get_var(pio_file, var1d_shrt, gstr1d);
    PIO_TF_CHECK_ERR(ret, "Failed to get 1d char var in file " // trim(filename))

    PIO_TF_CHECK_VAL((gstr1d, exp_shrt_str1d), "Got wrong value for short 1d char var")

    gstr1d = ''
    ret = PIO_get_var(pio_file, var1d_long, gstr1d);
    PIO_TF_CHECK_ERR(ret, "Failed to get 1d char var in file " // trim(filename))

    PIO_TF_CHECK_VAL((gstr1d, exp_long_str1d), "Got wrong value for long 1d char var")

    gstr1d = ''
    ret = PIO_get_var(pio_file, var1d_trnc, gstr1d);
    PIO_TF_CHECK_ERR(ret, "Failed to get 1d char var in file " // trim(filename))

    PIO_TF_CHECK_VAL((gstr1d, exp_trnc_str1d), "Got wrong value for truncatable 1d char var")

    gstr1d = ''
    ret = PIO_get_var(pio_file, var1d_midx, gstr1d);
    PIO_TF_CHECK_ERR(ret, "Failed to get 1d char var in file " // trim(filename))

    PIO_TF_CHECK_VAL((gstr1d, exp_midx_str1d), "Got wrong value for index write of 1d char var")

    call PIO_closefile(pio_file)
    call PIO_deletefile(pio_tf_iosystem_, filename);
  end do
  if(allocated(iotypes)) then
    deallocate(iotypes)
    deallocate(iotype_descs)
  end if

PIO_TF_AUTO_TEST_SUB_END test_put_get_str_idx

! Testing put/get of hyperslabs of a text variable
! Each string in the text variable is initialized with the variable name and
! index
! e.g. The string in the jth col and ith row of a 2d variable, var2d(j, i),
! is initialized to "var2d(j,i)"
! The contents of the variable is then modified/rewritten in two parts,
! 1) var2d(j,i) = "var2d(j,i)" is modified to "v__2d(j,i)"
! 2) var2d(j,i) = "v__2d(j,i)" is modified to "v__2_(j,i)"
PIO_TF_AUTO_TEST_SUB_BEGIN test_put_get_str_hslabs
  Implicit none
  type(file_desc_t) :: pio_file
  character(len=*), parameter :: filename = "test_pio_ncdf_get_str_hslabs.testfile"
  type(var_desc_t)  :: var1d, var2d, var3d

  integer, parameter :: SHORT_STR_LEN = 32
  integer, parameter :: LONG_STR_LEN = 128
  integer, parameter :: STR_LEN = 64

  character(len=*), parameter :: VAR_NAME_PREFIX1 = "var"
  character(len=*), parameter :: VAR_NAME_PREFIX2 = "v__"
  character(len=*), parameter :: VAR_NAME_SUFFIX1 = "d"
  character(len=*), parameter :: VAR_NAME_SUFFIX2 = "_"
  integer, parameter :: VAR1D_ID = 1
  integer, parameter :: VAR2D_ID = 2
  integer, parameter :: VAR3D_ID = 3
  character(len=STR_LEN) :: var1d_name, var1d_name_tmp_buf
  character(len=STR_LEN) :: var2d_name, var2d_name_tmp_buf
  character(len=STR_LEN) :: var3d_name, var3d_name_tmp_buf
  ! var*d_name = VAR_NAME_PREFIX* + VAR*D_ID + VAR_NAME_SUFFIX*
  character(len=*), parameter :: VAR_NAME_FMT = '(A3,I1,A1)'

  integer, parameter :: NDIMS = 4
  integer, dimension(NDIMS) :: pio_dims
  integer, parameter :: NUM_ROWS = 4
  integer, parameter :: NUM_COLS = 8
  integer, parameter :: NUM_STEPS = 6
  character(len=*), parameter :: dim0_name = "slen"
  character(len=*), parameter :: dim1_name = "row"
  character(len=*), parameter :: dim2_name = "col"
  character(len=*), parameter :: dim3_name = "step"

  character(len=STR_LEN) :: exp_str1d(NUM_ROWS)
  character(len=STR_LEN) :: exp_str2d(NUM_ROWS, NUM_COLS)
  character(len=STR_LEN) :: exp_str3d(NUM_ROWS, NUM_COLS, NUM_STEPS)
  character(len=1), dimension(:), allocatable :: tmp_str
  character(len=STR_LEN) :: gstr1d(NUM_ROWS)
  character(len=STR_LEN) :: gstr2d(NUM_ROWS, NUM_COLS)
  character(len=STR_LEN) :: gstr3d(NUM_ROWS, NUM_COLS, NUM_STEPS)

  integer, dimension(NDIMS) :: strt, cnt

  integer, dimension(:), allocatable :: iotypes
  character(len=PIO_TF_MAX_STR_LEN), dimension(:), allocatable :: iotype_descs
  integer :: num_iotypes

  ! Formats for the data written out in the text variable
  ! Each string in the variable is of the form
  ! "VAR_NAME(VAR_IDX,...)"
  ! e.g. For 2D var, var2d, var2d(j,i) = "var2d(j,i)"
  character(len=*), parameter :: VNAME_WITH_1D_IDX_FMT1 = '(A5,"(",I5,")")'
  character(len=*), parameter :: VNAME_WITH_2D_IDX_FMT1 = '(A5,"(",I5,",",I5,")")'
  character(len=*), parameter :: VNAME_WITH_3D_IDX_FMT1 = '(A5,"(",I5,",",I5,",",I5,")")'
  character(len=*), parameter :: VNAME_WITH_1D_IDX_FMT2 = '(A5,"[",I5,"]")'
  character(len=*), parameter :: VNAME_WITH_2D_IDX_FMT2 = '(A5,"[",I5,",",I5,"]")'
  character(len=*), parameter :: VNAME_WITH_3D_IDX_FMT2 = '(A5,"[",I5,",",I5,",",I5,"]")'

  integer :: i, j, k, l, m, row, col, step, ret

  num_iotypes = 0
  call PIO_TF_Get_nc_iotypes(iotypes, iotype_descs, num_iotypes)
  ! var1d_name = "var1d", var2d_name = "var2d", var3d_name="var3d"
  write(var1d_name, VAR_NAME_FMT) VAR_NAME_PREFIX1, VAR1D_ID, VAR_NAME_SUFFIX1
  write(var2d_name, VAR_NAME_FMT) VAR_NAME_PREFIX1, VAR2D_ID, VAR_NAME_SUFFIX1
  write(var3d_name, VAR_NAME_FMT) VAR_NAME_PREFIX1, VAR3D_ID, VAR_NAME_SUFFIX1

  do i=1,num_iotypes
    ! Init bufs used to write data to variables
    var1d_name_tmp_buf = var1d_name
    var2d_name_tmp_buf = var2d_name
    var3d_name_tmp_buf = var3d_name
    do row=1,NUM_ROWS
      write(exp_str1d(row), VNAME_WITH_1D_IDX_FMT1) var1d_name_tmp_buf, row
      do col=1,NUM_COLS
        write(exp_str2d(row,col), VNAME_WITH_2D_IDX_FMT1) var2d_name_tmp_buf, row, col
        do step=1,NUM_STEPS
          write(exp_str3d(row,col,step), VNAME_WITH_3D_IDX_FMT1) var3d_name_tmp_buf, row, col, step
        end do
      end do
    end do

    PIO_TF_LOG(0,*) "Testing type :", iotype_descs(i)
    ret = PIO_createfile(pio_tf_iosystem_, pio_file, iotypes(i), filename, PIO_CLOBBER)
    PIO_TF_CHECK_ERR(ret, "Failed to open:" // trim(filename))

    ret = PIO_def_dim(pio_file, dim0_name, STR_LEN, pio_dims(1))
    PIO_TF_CHECK_ERR(ret, "Failed to define dim 0:" // trim(filename))

    ret = PIO_def_dim(pio_file, dim1_name, NUM_ROWS, pio_dims(2))
    PIO_TF_CHECK_ERR(ret, "Failed to define dim 1:" // trim(filename))

    ret = PIO_def_dim(pio_file, dim2_name, NUM_COLS, pio_dims(3))
    PIO_TF_CHECK_ERR(ret, "Failed to define dim 2:" // trim(filename))

    ret = PIO_def_dim(pio_file, dim3_name, NUM_STEPS, pio_dims(4))
    PIO_TF_CHECK_ERR(ret, "Failed to define dim 3:" // trim(filename))

    ret = PIO_def_var(pio_file, var1d_name, PIO_char, (/pio_dims(1), pio_dims(2)/), var1d)
    PIO_TF_CHECK_ERR(ret, "Failed to define 1 dim char array or 1d array of strings in file " // trim(filename))

    ret = PIO_def_var(pio_file, var2d_name, PIO_char, (/pio_dims(1), pio_dims(2), pio_dims(3)/), var2d)
    PIO_TF_CHECK_ERR(ret, "Failed to define 2 dim char array or 2d array of strings in file " // trim(filename))

    ret = PIO_def_var(pio_file, var3d_name, PIO_char, pio_dims, var3d)
    PIO_TF_CHECK_ERR(ret, "Failed to define 3 dim char array or 3d array of strings in file " // trim(filename))

    ret = PIO_enddef(pio_file)
    PIO_TF_CHECK_ERR(ret, "Failed to enddef:" // trim(filename))

    ! Write the entire contents of the user array/buffer
    ! Each buffer value, the variable name with index, is of the form
    ! VAR_NAME_PREFIX1 + VAR1D_ID + VAR_NAME_SUFFIX1(VAR1D_INDEX)
    ! = "var" + VAR1D_ID + "d"(VAR1D_INDEX)
    ! e.g. var1d(1) = "var1d(1)"
    ret = PIO_put_var(pio_file, var1d, exp_str1d);
    PIO_TF_CHECK_ERR(ret, "Failed to put 1d array of strings in file " // trim(filename))

    ret = PIO_put_var(pio_file, var2d, exp_str2d);
    PIO_TF_CHECK_ERR(ret, "Failed to put 2d array of strings in file " // trim(filename))

    ret = PIO_put_var(pio_file, var3d, exp_str3d);
    PIO_TF_CHECK_ERR(ret, "Failed to put 3d array of strings in file " // trim(filename))

    ! Sync data to disk
#ifdef PIO_TEST_CLOSE_OPEN_FOR_SYNC
    call PIO_closefile(pio_file)

    ret = PIO_openfile(pio_tf_iosystem_, pio_file, iotypes(i), filename, PIO_write)
    PIO_TF_CHECK_ERR(ret, "Failed to reopen:" // trim(filename))

    ret = PIO_inq_varid(pio_file, var1d_name, var1d)
    PIO_TF_CHECK_ERR(ret, "Failed to inquire 1d array of strings var in file " // trim(filename))

    ret = PIO_inq_varid(pio_file, var2d_name, var2d)
    PIO_TF_CHECK_ERR(ret, "Failed to inquire 2d array of strings var in file " // trim(filename))

    ret = PIO_inq_varid(pio_file, var3d_name, var3d)
    PIO_TF_CHECK_ERR(ret, "Failed to inquire 3d array of strings var in file " // trim(filename))
#else
    call PIO_syncfile(pio_file)
#endif

    ! Modify the prefixes in the buffer contents
    ! Each buffer value, the variable name with index, is of the form
    ! VAR_NAME_PREFIX1 + VAR1D_ID + VAR_NAME_SUFFIX1(VAR1D_INDEX)
    ! = "var" + VAR1D_ID + "d"(VAR1D_INDEX)
    ! e.g. var1d(1) = "var1d(1)" would be changed to "v__1d(1)

    ! var1d_name = "v__1d", var2d_name = "v__2d", var3d_name="v__3d"
    write(var1d_name_tmp_buf, VAR_NAME_FMT) VAR_NAME_PREFIX2, VAR1D_ID, VAR_NAME_SUFFIX1
    write(var2d_name_tmp_buf, VAR_NAME_FMT) VAR_NAME_PREFIX2, VAR2D_ID, VAR_NAME_SUFFIX1
    write(var3d_name_tmp_buf, VAR_NAME_FMT) VAR_NAME_PREFIX2, VAR3D_ID, VAR_NAME_SUFFIX1

    do row=1,NUM_ROWS
      write(exp_str1d(row), VNAME_WITH_1D_IDX_FMT1) var1d_name_tmp_buf, row
      do col=1,NUM_COLS
        write(exp_str2d(row,col), VNAME_WITH_2D_IDX_FMT1) var2d_name_tmp_buf, row, col
        do step=1,NUM_STEPS
          write(exp_str3d(row,col,step), VNAME_WITH_3D_IDX_FMT1) var3d_name_tmp_buf, row, col, step
        end do
      end do
    end do

    ! Write a hslab of 1d text variable to modify prefix of each string
    ! in the variable, 1 string at a time
    do row=1,NUM_ROWS
      strt = 1
      cnt = 0
      strt(1) = 1
      strt(2) = row
      cnt(1) = len_trim(VAR_NAME_PREFIX2)
      cnt(2) = 1

      ! Pack the data written out into an array of strings, each of length 1
      ! tmp_str(1) = "v", tmp_str(2) = "_", tmp_str(3) = "_"
      ! ...
      allocate(tmp_str(cnt(1) * cnt(2)))
      do j=1, cnt(2)
        do k=1, cnt(1)
          tmp_str((j - 1) * cnt(1) + k)(1:1) = VAR_NAME_PREFIX2(k:k)
        end do
      end do

      ret = PIO_put_var(pio_file, var1d, strt, cnt, tmp_str);
      PIO_TF_CHECK_ERR(ret, "Failed to put string prefixes in file " // trim(filename))

      deallocate(tmp_str)
    end do

    ! Write a hslab of 2d text variable to modify prefix of each string
    ! in the variable, a 1d array/col of strings at a time
    do col=1,NUM_COLS
      strt = 1
      cnt = 0
      strt(1) = 1
      strt(2) = 1
      strt(3) = col
      cnt(1) = len_trim(VAR_NAME_PREFIX2)
      cnt(2) = NUM_ROWS
      cnt(3) = 1

      ! Pack the data written out into an array of strings, each of length 1
      ! tmp_str(1) = "v", tmp_str(2) = "_", tmp_str(3) = "_"
      ! tmp_str(4) = "v", tmp_str(5) = "_", tmp_str(6) = "_"
      ! ...
      allocate(tmp_str(cnt(1) * cnt(2) * cnt(3)))
      do l=1, cnt(3)
        do j=1, cnt(2)
          do k=1, cnt(1)
            tmp_str((l - 1) * cnt(2) * cnt(1) +&
                    (j - 1) * cnt(1) + k)(1:1) = VAR_NAME_PREFIX2(k:k)
          end do
        end do
      end do

      ret = PIO_put_var(pio_file, var2d, strt, cnt, tmp_str);
      PIO_TF_CHECK_ERR(ret, "Failed to put 1d array of string prefixes in file " // trim(filename))

      deallocate(tmp_str)
    end do

    ! Write a hslab of 3d text variable to modify prefix of each string
    ! in the variable, 1 2d array of strings at a time
    do step=1,NUM_STEPS
      strt = 1
      cnt = 0
      strt(1) = 1
      strt(2) = 1
      strt(3) = 1
      strt(4) = step
      cnt(1) = len_trim(VAR_NAME_PREFIX2)
      cnt(2) = NUM_ROWS
      cnt(3) = NUM_COLS
      cnt(4) = 1

      ! Pack the data written out into an array of strings, each of length 1
      ! tmp_str(1) = "v", tmp_str(2) = "_", tmp_str(3) = "_"
      ! tmp_str(4) = "v", tmp_str(5) = "_", tmp_str(6) = "_"
      ! ...
      allocate(tmp_str(cnt(1) * cnt(2) * cnt(3) * cnt(4)))
      do m=1, cnt(4)
        do l=1, cnt(3)
          do j=1, cnt(2)
            do k=1, cnt(1)
              tmp_str((m - 1) * cnt(3) * cnt(2) * cnt(1) +&
                      (l - 1) * cnt(2) * cnt(1) +&
                      (j - 1) * cnt(1) + k)(1:1) = VAR_NAME_PREFIX2(k:k)
            end do
          end do
        end do
      end do

      ret = PIO_put_var(pio_file, var3d, strt, cnt, tmp_str);
      PIO_TF_CHECK_ERR(ret, "Failed to put 2d array of string prefixes in file " // trim(filename))

      deallocate(tmp_str)
    end do

    ! Sync data to disk
#ifdef PIO_TEST_CLOSE_OPEN_FOR_SYNC
    call PIO_closefile(pio_file)

    ret = PIO_openfile(pio_tf_iosystem_, pio_file, iotypes(i), filename, PIO_write)
    PIO_TF_CHECK_ERR(ret, "Failed to reopen:" // trim(filename))

    ret = PIO_inq_varid(pio_file, var1d_name, var1d)
    PIO_TF_CHECK_ERR(ret, "Failed to inquire 1d array of strings var in file " // trim(filename))

    ret = PIO_inq_varid(pio_file, var2d_name, var2d)
    PIO_TF_CHECK_ERR(ret, "Failed to inquire 2d array of strings var in file " // trim(filename))

    ret = PIO_inq_varid(pio_file, var3d_name, var3d)
    PIO_TF_CHECK_ERR(ret, "Failed to inquire 3d array of strings var in file " // trim(filename))
#else
    call PIO_syncfile(pio_file)
#endif

    ret = PIO_get_var(pio_file, var1d, gstr1d);
    PIO_TF_CHECK_ERR(ret, "Failed to get 1d char var in file " // trim(filename))

    PIO_TF_CHECK_VAL((gstr1d, exp_str1d), "Got wrong value for 1d char var with modified prefix")

    ret = PIO_get_var(pio_file, var2d, gstr2d);
    PIO_TF_CHECK_ERR(ret, "Failed to get 2d char var in file " // trim(filename))

    PIO_TF_CHECK_VAL((gstr2d, exp_str2d), "Got wrong value for 2d char var with modified prefix")

    ret = PIO_get_var(pio_file, var3d, gstr3d);
    PIO_TF_CHECK_ERR(ret, "Failed to get 3d char var in file " // trim(filename))

    PIO_TF_CHECK_VAL((gstr3d, exp_str3d), "Got wrong value for 3d char var with modified prefix")

    ! Modify the suffixes in the buffer contents
    ! Each buffer value, the variable name with index, is of the form
    ! VAR_NAME_PREFIX2 + VAR1D_ID + VAR_NAME_SUFFIX1(VAR1D_INDEX)
    ! = "v__" + VAR1D_ID + "d"(VAR1D_INDEX)
    ! e.g. var1d(1) = "v__1d(1)" would be changed to "v__1_(1)

    ! var1d_name = "v__1_", var2d_name = "v__2_", var3d_name="v__3_"
    write(var1d_name_tmp_buf, VAR_NAME_FMT) VAR_NAME_PREFIX2, VAR1D_ID, VAR_NAME_SUFFIX2
    write(var2d_name_tmp_buf, VAR_NAME_FMT) VAR_NAME_PREFIX2, VAR2D_ID, VAR_NAME_SUFFIX2
    write(var3d_name_tmp_buf, VAR_NAME_FMT) VAR_NAME_PREFIX2, VAR3D_ID, VAR_NAME_SUFFIX2

    do row=1,NUM_ROWS
      write(exp_str1d(row), VNAME_WITH_1D_IDX_FMT1) var1d_name_tmp_buf, row
      do col=1,NUM_COLS
        write(exp_str2d(row,col), VNAME_WITH_2D_IDX_FMT1) var2d_name_tmp_buf, row, col
        do step=1,NUM_STEPS
          write(exp_str3d(row,col,step), VNAME_WITH_3D_IDX_FMT1) var3d_name_tmp_buf, row, col, step
        end do
      end do
    end do

    ! Write hslab of 1d text variable to modify a part of each string in the variable,
    ! 1 string at a time
    do row=1,NUM_ROWS
      strt = 1
      cnt = 0
      ! Skip VAR_NAME_PREFIX2 and VAR1D_ID
      strt(1) = (len_trim(VAR_NAME_PREFIX2) + 1) + 1
      strt(2) = row
      cnt(1) = len_trim(VAR_NAME_SUFFIX2)
      cnt(2) = 1

      ! Pack the data/suffix written out into an array of strings, each of length 1
      ! tmp_str(1) = "_",
      ! tmp_str(2) = "_",
      ! ...
      allocate(tmp_str(cnt(1) * cnt(2)))
      do j=1, cnt(2)
        do k=1, cnt(1)
          tmp_str((j - 1) * cnt(1) + k)(1:1) = VAR_NAME_SUFFIX2(k:k)
        end do
      end do

      ret = PIO_put_var(pio_file, var1d, strt, cnt, tmp_str);
      PIO_TF_CHECK_ERR(ret, "Failed to put string suffixes in file " // trim(filename))

      deallocate(tmp_str)
    end do

    ! Write an hslab of data to modify part of the variable, 1 1d array of strings
    ! at a time
    do col=1,NUM_COLS
      strt = 1
      cnt = 0
      ! Skip VAR_NAME_PREFIX2 and VAR2D_ID
      strt(1) = (len_trim(VAR_NAME_PREFIX2) + 1) + 1
      strt(2) = 1
      strt(3) = col
      cnt(1) = len_trim(VAR_NAME_SUFFIX2)
      cnt(2) = NUM_ROWS
      cnt(3) = 1

      ! Pack the data/suffix written out into an array of strings, each of length 1
      ! tmp_str(1) = "_",
      ! tmp_str(2) = "_",
      ! ...
      allocate(tmp_str(cnt(1) * cnt(2) * cnt(3)))
      do l=1, cnt(3)
        do j=1, cnt(2)
          do k=1, cnt(1)
            tmp_str((l - 1) * cnt(2) * cnt(1) +&
                    (j - 1) * cnt(1) + k)(1:1) = VAR_NAME_SUFFIX2(k:k)
          end do
        end do
      end do

      ret = PIO_put_var(pio_file, var2d, strt, cnt, tmp_str);
      PIO_TF_CHECK_ERR(ret, "Failed to put 1d array of string suffixes in file " // trim(filename))

      deallocate(tmp_str)
    end do

    ! Write an hslab of data to modify part of the variable, 1 2d array of strings
    ! at a time
    do step=1,NUM_STEPS
      strt = 1
      cnt = 0
      ! Skip VAR_NAME_PREFIX2 and VAR3D_ID
      strt(1) = (len_trim(VAR_NAME_PREFIX2) + 1) + 1
      strt(2) = 1
      strt(3) = 1
      strt(4) = step
      cnt(1) = len_trim(VAR_NAME_SUFFIX2)
      cnt(2) = NUM_ROWS
      cnt(3) = NUM_COLS
      cnt(4) = 1

      ! Pack the data/suffix written out into an array of strings, each of length 1
      ! tmp_str(1) = "_",
      ! tmp_str(2) = "_",
      ! ...
      allocate(tmp_str(cnt(1) * cnt(2) * cnt(3) * cnt(4)))
      do m=1, cnt(4)
        do l=1, cnt(3)
          do j=1, cnt(2)
            do k=1, cnt(1)
              tmp_str((m - 1) * cnt(3) * cnt(2) * cnt(1) +&
                      (l - 1) * cnt(2) * cnt(1) +&
                      (j - 1) * cnt(1) + k)(1:1) = VAR_NAME_SUFFIX2(k:k)
            end do
          end do
        end do
      end do

      ret = PIO_put_var(pio_file, var3d, strt, cnt, tmp_str);
      PIO_TF_CHECK_ERR(ret, "Failed to put 2d array of string suffixes in file " // trim(filename))

      deallocate(tmp_str)
    end do

    ! Sync data to disk
#ifdef PIO_TEST_CLOSE_OPEN_FOR_SYNC
    call PIO_closefile(pio_file)

    ret = PIO_openfile(pio_tf_iosystem_, pio_file, iotypes(i), filename, PIO_nowrite)
    PIO_TF_CHECK_ERR(ret, "Failed to reopen:" // trim(filename))

    ret = PIO_inq_varid(pio_file, var1d_name, var1d)
    PIO_TF_CHECK_ERR(ret, "Failed to inquire 1d array of strings var in file " // trim(filename))

    ret = PIO_inq_varid(pio_file, var2d_name, var2d)
    PIO_TF_CHECK_ERR(ret, "Failed to inquire 2d array of strings var in file " // trim(filename))

    ret = PIO_inq_varid(pio_file, var3d_name, var3d)
    PIO_TF_CHECK_ERR(ret, "Failed to inquire 3d array of strings var in file " // trim(filename))
#else
    call PIO_syncfile(pio_file)
#endif

    ret = PIO_get_var(pio_file, var1d, gstr1d);
    PIO_TF_CHECK_ERR(ret, "Failed to get 1d char var in file " // trim(filename))

    PIO_TF_CHECK_VAL((gstr1d, exp_str1d), "Got wrong value for 1d char var with modified suffixes")

    ret = PIO_get_var(pio_file, var2d, gstr2d);
    PIO_TF_CHECK_ERR(ret, "Failed to get 2d char var in file " // trim(filename))

    PIO_TF_CHECK_VAL((gstr2d, exp_str2d), "Got wrong value for 2d char var with modified suffixes")

    ret = PIO_get_var(pio_file, var3d, gstr3d);
    PIO_TF_CHECK_ERR(ret, "Failed to get 3d char var in file " // trim(filename))

    PIO_TF_CHECK_VAL((gstr3d, exp_str3d), "Got wrong value for 3d char var with modified suffixes")

    call PIO_closefile(pio_file)
    call PIO_deletefile(pio_tf_iosystem_, filename);
  end do
  if(allocated(iotypes)) then
    deallocate(iotypes)
    deallocate(iotype_descs)
  end if

PIO_TF_AUTO_TEST_SUB_END test_put_get_str_hslabs

! This test puts and gets variables that can involve implicit type conversion
PIO_TF_TEMPLATE<PIO_TF_PREDEF_TYPENAME PIO_TF_DATA_TYPE, PIO_TF_PREDEF_TYPENAME PIO_TF_FC_DATA_TYPE>
PIO_TF_AUTO_TEST_SUB_BEGIN test_put_get_type_conversion
  Implicit none
  integer, parameter :: DIM_LEN = 100
  type(var_desc_t)  :: pio_var_int, pio_var_real, pio_var_double
  type(file_desc_t) :: pio_file
  character(len=PIO_TF_MAX_STR_LEN) :: data_fname = "pio_test_put_get_type_conversion.nc"
  character(len=*), parameter :: PIO_VAR_INT_NAME = 'PIO_TF_test_var_int'
  character(len=*), parameter :: PIO_VAR_REAL_NAME = 'PIO_TF_test_var_real'
  character(len=*), parameter :: PIO_VAR_DBL_NAME = 'PIO_TF_test_var_dbl'
  PIO_TF_FC_DATA_TYPE, dimension(DIM_LEN) :: pval, gval
  integer :: pio_dim
  ! iotypes = valid io types
  integer, dimension(:), allocatable :: iotypes
  character(len=PIO_TF_MAX_STR_LEN), dimension(:), allocatable :: iotype_descs
  integer :: num_iotypes
  integer :: i, ierr

  pval = pio_tf_world_sz_

  num_iotypes = 0
  call PIO_TF_Get_nc_iotypes(iotypes, iotype_descs, num_iotypes)
  do i=1,num_iotypes
    PIO_TF_LOG(0,*) "Testing : PIO_TF_DATA_TYPE : ", iotype_descs(i)

    ierr = PIO_createfile(pio_tf_iosystem_, pio_file, iotypes(i), data_fname, PIO_CLOBBER)
    PIO_TF_CHECK_ERR(ierr, "Could not create file " // trim(data_fname))

    ierr = PIO_def_dim(pio_file, 'PIO_TF_test_dim', DIM_LEN, pio_dim)
    PIO_TF_CHECK_ERR(ierr, "Failed to define a dim : " // trim(data_fname))

    ierr = PIO_def_var(pio_file, PIO_VAR_INT_NAME, PIO_int, (/pio_dim/), pio_var_int)
    PIO_TF_CHECK_ERR(ierr, "Failed to define a var of int type : " // trim(data_fname))

    ierr = PIO_def_var(pio_file, PIO_VAR_REAL_NAME, PIO_real, (/pio_dim/), pio_var_real)
    PIO_TF_CHECK_ERR(ierr, "Failed to define a var of real type : " // trim(data_fname))

    ierr = PIO_def_var(pio_file, PIO_VAR_DBL_NAME, PIO_double, (/pio_dim/), pio_var_double)
    PIO_TF_CHECK_ERR(ierr, "Failed to define a var of double type : " // trim(data_fname))

    ierr = PIO_enddef(pio_file)
    PIO_TF_CHECK_ERR(ierr, "Failed to end redef mode : " // trim(data_fname))

    ! Put the int type variable out (data conversion might occur: real => int, double => int)
    ierr = PIO_put_var(pio_file, pio_var_int, pval)
    PIO_TF_CHECK_ERR(ierr, "Failed to put a var of int type : " // trim(data_fname))

    ! Put the real type variable out (data conversion might occur: int => real, double => real)
    ierr = PIO_put_var(pio_file, pio_var_real, pval)
    PIO_TF_CHECK_ERR(ierr, "Failed to put a var of real type : " // trim(data_fname))

    ! Put the double type variable out (data conversion might occur: int => double, real => double)
    ierr = PIO_put_var(pio_file, pio_var_double, pval)
    PIO_TF_CHECK_ERR(ierr, "Failed to put a var of double type : " // trim(data_fname))

#ifdef PIO_TEST_CLOSE_OPEN_FOR_SYNC
    call PIO_closefile(pio_file)

    ierr = PIO_openfile(pio_tf_iosystem_, pio_file, iotypes(i), data_fname, PIO_nowrite)
    PIO_TF_CHECK_ERR(ierr, "Could not reopen file " // trim(data_fname))

    ierr = PIO_inq_varid(pio_file, PIO_VAR_INT_NAME, pio_var_int)
    PIO_TF_CHECK_ERR(ierr, "Cannot inq int var " // trim(data_fname))

    ierr = PIO_inq_varid(pio_file, PIO_VAR_REAL_NAME, pio_var_real)
    PIO_TF_CHECK_ERR(ierr, "Cannot inq real var " // trim(data_fname))

    ierr = PIO_inq_varid(pio_file, PIO_VAR_DBL_NAME, pio_var_double)
    PIO_TF_CHECK_ERR(ierr, "Cannot inq double var " // trim(data_fname))
#else
    call PIO_syncfile(pio_file)
#endif

    ! Get the int type variable back (data conversion might occur: int => real, int => double)
    gval = 0
    ierr = PIO_get_var(pio_file, pio_var_int, gval)
    PIO_TF_CHECK_ERR(ierr, "Failed to get a var of int type : " // trim(data_fname))

    PIO_TF_CHECK_VAL((gval, pval), "Got wrong val")

    ! Get the real type variable back (data conversion might occur: real => int, real => double)
    gval = 0
    ierr = PIO_get_var(pio_file, pio_var_real, gval)
    PIO_TF_CHECK_ERR(ierr, "Failed to get a var of real type : " // trim(data_fname))

    PIO_TF_CHECK_VAL((gval, pval), "Got wrong val")

    ! Get the double type variable back (data conversion might occur: double => int, double => real)
    gval = 0
    ierr = PIO_get_var(pio_file, pio_var_double, gval)
    PIO_TF_CHECK_ERR(ierr, "Failed to get a var of double type : " // trim(data_fname))

    PIO_TF_CHECK_VAL((gval, pval), "Got wrong val")

    call PIO_closefile(pio_file)
    call PIO_deletefile(pio_tf_iosystem_, data_fname);
  end do
  if(allocated(iotypes)) then
    deallocate(iotypes)
    deallocate(iotype_descs)
  end if

PIO_TF_AUTO_TEST_SUB_END test_put_get_type_conversion
